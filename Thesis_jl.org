#+title: Bachelor Thesis
#+BIBLIOGRAPHY: ~/org/resources/bibliography/refs.bib
#+property: header-args:python :noweb strip-export
* Utility functions
#+name: imports
#+begin_src julia :session jl :results silent :exports none
using Plots
using LinearAlgebra
#+end_src

#+begin_src julia :tangle multisolver.jl :eval never
include("/home/jon/Projects/julia_tst/utils.jl")
#+end_src

#+begin_src  julia :tangle utils.jl :eval never
###############################################################################
#                  Common Utility Functions For Multi Solvers                 #
###############################################################################

"""
restricts an array on the small grid to an array in the large grid asserts size arr=2^n + 2 and returns ret=2^(n-1) + 2

Returns
---------------------------
large grid array + padding
"""
function restrict(arr, G)
    shape = (size(arr) .- 2) .÷ 2
    ret = zeros(shape .+ 2)
    for I in CartesianIndices(ret)[2:end-1, 2:end-1]
        i, j = I.I
        g = [
            G(2 * i - 1, 2 * j - 1, (size(arr) .- 2)...),
            G(2 * i - 1, 2 * j, (size(arr) .- 2)...),
            G(2 * i, 2 * j - 1, (size(arr) .- 2)...),
            G(2 * i, 2 * j, (size(arr) .- 2)...)
        ]
        if sum(g) == 0
            ret[I] = 0
        else
            ret[I] = (
                1 / sum(g)
                ,*
                dot(g,
                    [
                        arr[2*i-1, 2*j-1],
                        arr[2*i-1, 2*j],
                        arr[2*i, 2*j-1],
                        arr[2*i, 2*j]
                    ]
                )
            )
        end
    end
    return ret
end

"""
    prolong(arr , G)

interpolates int a smaller grid by a factor of 2

"""
function prolong(arr, G)
    inner_shape = (size(arr).-2).*2
    ret = zeros(inner_shape .+2)
    ONE = oneunit(CartesianIndices(arr)[1])
    for I in CartesianIndices(arr)[2:end-1, 2:end-1]
        Ind = 2 * (I - ONE) + ONE
        for J in (Ind - ONE):Ind
            ret[J] = G(J.I... , inner_shape... ) * arr[I]
        end
    end
    return ret
end

struct multi_solver
    phase::Matrix{Float64}
    potential::Matrix{Float64}
    xi::Matrix{Float64}
    psi::Matrix{Float64}
    epsilon::Float64
    h::Float64
    dt::Float64
    W_prime::Function
    len::Int
    width::Int

end

function testgrid(M, len)
    grid = Array{multi_solver}(undef, len)
    phase = zeros(size(M) .+ 2)
    phase[2:end-1, 2:end-1] = M
    W_prime(x) = -x * (1 - x^2)
    h0 = 3e-3


    for i = 1:len
        grid[i] = multi_solver(zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            8e-3, h0 * 2^i, 1e-3,
            W_prime,
            size(M, 1) ÷ i, size(M, 2) ÷ i)

    end
    copyto!(grid[1].phase, phase)
    return grid

end
"""
    restrict!(smallgrid_solver::multi_solver , largegrid_solver::multi_solver)::multi_solver

------------
Requires
----------
smallgrid solver and largegid solvers to be multiple of 2 from each other bar padding eg. (66x66)->(34x34)


TBW
"""
function restrict_solver!(smallgrid_solver::multi_solver, largegrid_solver::multi_solver)
    copy!(largegrid_solver.phase, restrict(smallgrid_solver.phase, G))
    copy!(largegrid_solver.potential, restrict(smallgrid_solver.potential, G))
    return nothing
end
#+end_src

* Cahn Hillard Equation Overview
Partial Differential Equation (PDE) solving the state of a 2 Phase Fluid[cite:@Wu_2022]. The form of the Cahn Hillard Equation used for the remainder of this thesis is:
where \( \phi\) is the so-called phase field. Demarking the different states of the fluids through an Interval \(I=[-1,1] \) and where \(\partial I = \{-1,1\} \) represents full state of one fluid. \(\varepsilon > 0 \) is  a positive constant
#+name: eq:CH
\begin{align}
\phi _t(x,t) &= \Delta  \mu \\
\mu &= - \varepsilon^2 \Delta \phi   + W'(\phi)
\end{align}
# describing the width of the phase transition
, and \(\mu\) is the chemical potential[cite:@Wu_2022]. While the Cahn Hillard exist in a more general form taking the fluid's mobility \(M(\Phi) \) into account, we will assume \(M(\Phi) = 1 \), simplifying the CH-Equations used in [cite:@Wu_2022] [cite:@SHIN20117441] to what is stated above.


The Advantages of the Cahn Hillard Approach as compared to traditional fluid dynamics solvers are for example: "explicit tracking of the interface"[cite:@Wu_2022], as well as "evolution of complex geometries and topological changes [...] in a natural way"[cite:@Wu_2022]
In practice it enables linear interpolation between different formulas on different phases
** TODO Derivation from paper
*** Free energy
The Cahn Hillard Equations can be motivated Using a *Ginzburg Landau* type free energy equation:
\begin{align*}
E^{\text{bulk}} = \int_{\Omega} \frac{\varepsilon^2}{2} |\nabla \phi |^2 + W(\phi) \, dx
\end{align*}
where \(W(\phi) \) denotes the (Helmholtz) free energy density of mixing.""[cite:@Wu_2022] and will be approximated in further calculations as \(W(\phi) = \frac{(1-\phi ^2)^2}{4}\) as used in[cite:@SHIN20117441]

The chemical potential then follows as derivative of Energy in respect to time.
\begin{align*}
 \mu &= \frac{\delta E_{bulk}(\phi)}{\delta \phi} = -\varepsilon^2 \Delta \phi + W'(\phi)
\end{align*}

*** Derivation by mass balance
The Cahn Hillard equation then can be motivated as follows:
consider
#+name: eq:massbal
\begin{equation}
    \partial_t \phi + \nabla J = 0
\end{equation}
where *J* is mass flux. [[eq:massbal]] then states that the change in mass balances the change of the phasefield.
Using the no-flux boundry conditions:
\begin{align}
J \cdot n &= 0 & \partial\Omega &\times (0,T)\\
\partial_n\phi &= 0 & \partial\Omega &\times (0,T)
\end{align}
conservation of mass follows see[cite:@Wu_2022].

Using:
\begin{align}
J &= - \nabla \mu
\end{align}
which conceptionally sets mass flux to equalize the potential energy gradient, leads to the formulation of the CH equations as stated above. Additionally, the boundary conditions evaluate to:
\begin{align*}
 - \nabla \mu &= 0 \\
\partial_n \phi = 0
\end{align*}
ie no flow leaves and potential on the border doesn't change.
Then for \(\phi \) then follows:
\begin{align*}
\frac{d}{dt}E^{bulk}(\phi(t)) &= \int_{\Omega} ( \varepsilon^2 \nabla \phi \cdot \nabla \partial_t \phi + W'(\phi) \partial_t \phi) \ d x \\
&= - \int_{ \Omega } |\nabla \mu|^2 \ d x, & \forall t \in (0,T)
\end{align*}
hence the Free Energy is decreasing in time.
* Baseline Multigrid solver:
As baseline for further experiments a multi grid method based on finite differences by[cite:@SHIN20117441]. Is used.
** Discretization:
it discretizes the phasefield and potential energy \( \phi, \mu \) into a grid wise functions \(\phi_{ij}, \mu_{ij} \) and defines the partial derivatives \( D_xf_{ij}, \ D_yf_{ij} \) using the differential quotients:
\begin{align}
D_xf_{i+\frac{1}{2} j} &= \frac{f_{i+1j} - f_{ij}}{h} & D_yf_{ij+\frac{1}{2}} &= \frac{f_{ij+1} - f_{ij}}{h}
\end{align}
for \( \nabla f, \Delta f \) then follows:
#+name: eq:discretization
\begin{align*}
\nabla_d f_{ij} &= (D_x f_{i+1j} , \ D_y f_{ij+1}) \\
 \Delta_d f_{ij} &= \frac{D_x f_{i+\frac{1}{2}j} -  D_x f_{i-\frac{1}{2}j} + D_y f_{ij+\frac{1}{2}} - D_y f_{ij-\frac{1}{2}}}{h} = \nabla_d \cdot  \nabla_d f_{ij}
\end{align*}
the authors further adapt the discretized phasefield by the characteristic function of the domain \( \Omega\):
\begin{align*}
G(x,y) &=
\begin{cases}
1 & (x,y) \in  \Omega \\
0 & (x,y) \not\in  \Omega
\end{cases}
\end{align*}

To simplify notation the following abbreviations are used:

Math: \(  \Sigma_G f_{ij} = G_{i+\frac{1}{2}j} f^{n + \frac{1}{2},m}_{i+1j} +  G_{i-\frac{1}{2}j} f^{n + \frac{1}{2},m}_{i-1j} + G_{ij+\frac{1}{2}}  f^{n + \frac{1}{2},m}_{ij+1} + G_{ij-\frac{1}{2}} f^{n + \frac{1}{2},m}_{ij-1}  \) Code: ~discrete_weigted_neigbour_sum(i,j,...)~ and Math: \(  \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}  \) Code: ~neighbours_in_domain(i,j,G)~ the expansion of \( \nabla_{d} \cdot G_{ij} \nabla_{d} f_{ij}= \Sigma_{G}f_{ij} - \Sigma_{G} \cdot f_{ij} \) .
#+begin_src julia :tangle utils.jl :eval never
"""
    neighbours_in_domain(i, j, G, len, width)

TBW
counts neigbours in domain
"""
function neighbours_in_domain(i, j, G, len, width)
    (
        G(i + 0.5, j, len, width)
        + G(i - 0.5, j, len, width)
        + G(i, j + 0.5, len, width)
        + G(i, j - 0.5, len, width)
    )

end

"""
    discrete_G_weigted_neigbour_sum(i, j, arr, G, len, width)

TBW
--------
sums all neighbours depending on wheter tey are in the domain determined by G
"""
function discrete_G_weigted_neigbour_sum(i, j, arr, G, len, width)
    (
        G(i + 0.5, j, len, width) * arr[i+1, j]
        + G(i - 0.5, j, len, width) * arr[i-1, j]
        + G(i, j + 0.5, len, width) * arr[i, j+1]
        + G(i, j - 0.5, len, width) * arr[i, j-1]
    )
end
#+end_src
To account for boundry conditions and arbitrary shaped domains.
The authors [cite:@SHIN20117441] then define the discrete CH Equation adapted for Domain, as:
\begin{align*}
\frac{\phi_{ij}^{n+1} - \phi_{ij}^n}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+1} )  \\
 \mu_{ij}^{n+1} &= 2\phi_{ij}^{n+1} - \varepsilon^2  \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1} ) + W'(\phi_{ij}^n) - 2\phi _{ij}^n
\end{align*}
** Test Data:
For testing and later training, a multitude o different phasefields where used. Notably an assortment of randomly placed circles, squares, and arbitrary generated values

#+name:inputs
| Size | blobs | blobsize | norm |
|------+-------+----------+------|
|   64 |    10 |       10 |    2 |
|   64 |    10 |       10 |  100 |
|  512 |    20 |       50 |    2 |

#+name: testdata
#+begin_src julia :eval never :tangle utils.jl
function testdata(gridsize , blobs , radius ,norm)
rngpoints = rand(1:gridsize, 2, blobs)
M = zeros(gridsize,gridsize) .- 1
for p in axes(rngpoints , 2)
    point = rngpoints[:, p]
    for I in CartesianIndices(M)
        if (LinearAlgebra.norm(point .- I.I  , norm) < radius)
            M[I] = 1
        end
    end
end
M

end
#+end_src

#+name: fig:testinput
#+begin_src julia-vterm :results file graphics  :file testdata.svg :noweb strip-export    :exports results
using Plots
using LaTeXStrings
using LinearAlgebra
<<testdata>>
p0 = heatmap(testdata(512, 20 , 50, 2));
p1 = heatmap(testdata(512 , 20 , 50 ,Inf));
p2 = heatmap(testdata(64 , 10 , 10,2));
p3 = heatmap(testdata(64 , 10 , 10 ,Inf));
p = plot(p0,p1,p2,p3, aspectratio=:auto, layout=(2,2));
savefig(p,"testdata.svg")
#+end_src

#+caption: Examples of different phasefields used as initial condition later on
#+RESULTS: fig:testinput
[[file:testdata.svg]]
** adaptations to the simplified problem
even tough this work uses rectangular domains, the adaptation of the algorithm is simplified by the domain indicator function, as well as 0 padding, in order to correctly include the boundary conditions of the CH equation.
Therefore, the internal representation of the adapted algorithm considers phasefield and potential field \( \phi , \mu \) as 2D arrays of shape \( (N_x + 2 , N_y + 2) \) in order to accommodate padding. Where N_x and N_y are the number of steps in x-/y-Direction respectively.
Hence, we define the discrete domain function as:
\begin{align*}
G_{ij} &=
\begin{cases}
1 & (i,j) \in  [1,N_x+1] \times  [1,N_y+1] \\
0 & \text{else}
\end{cases}
\end{align*}

#+begin_src julia :tangle utils.jl :eval never
"""
Boundry indicator function

Returns
---------------
1 if index i,j is in bounds(without padding) and 0 else
"""
function G(i, j, len, width)
    if 2 <= i <= len + 1 && 2 <= j <= width + 1
        return 1.0
    else
        return 0.0
    end
end
#+end_src
** PDE as Operator
and derive the iteration operator \( L(\phi^{n+1} , \mu^{n+\frac{1}{2}}) = (\zeta^n ,\psi^n) \)
\begin{align*}
L
\begin{pmatrix}
\phi^{n+1} \\
\mu^{n+\frac{1}{2}}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi^{n+1}}{\Delta t} - \nabla _d \cdot  ( G_{ij} \nabla _d \mu^{n+\frac{1}{2}} ) \\
\varepsilon^2 \nabla _d \cdot  (G_{ij} \nabla_d \phi_{ij}^{n+1}) - 2\phi_{ij}^{n+1} + \mu_{ij}^{n+\frac{1}{2}}
\end{pmatrix}
\end{align*}
implented as
#+begin_src julia :tangle multisolver.jl :eval never
function L(solver::multi_solver,i,j , phi , mu)
    xi = solver.phase[i, j] / solver.dt -
         (discrete_G_weigted_neigbour_sum(i, j, solver.potential, G, solver.len, solver.width)
          -
          neighbours_in_domain(i, j, G, solver.len, solver.width) * mu )/solver.h^2
    psi = solver.epsilon^2/solver.h^2 *
          (discrete_G_weigted_neigbour_sum(i, j, solver.phase, G, solver.len, solver.width)
           -
           neighbours_in_domain(i, j, G, solver.len, solver.width) * phi) - 2 * phi + mu
    return [xi, psi]
end
#+end_src

Furthermore, as it enabled a Newton  iteration we state its derivative in respect to the current gridpoint \( (i,j)^{T} \) in as:

\begin{align*}
DL\begin{pmatrix}
\phi \\
\mu
\end{pmatrix} &= \begin{pmatrix}
\frac{1}{\Delta t} & \frac{1}{h^2}\Sigma_{G}  \\
-\frac{\varepsilon^2}{h^2}\Sigma_{G} - 2 & 1
\end{pmatrix}
\end{align*}
implemented:
#+begin_src julia :tangle multisolver.jl :eval never
function dL(solver::multi_solver , i , j)
    return [ (1/solver.dt) (1/solver.h^2*neighbours_in_domain(i,j,G,solver.len , solver.width));
             (-1*solver.epsilon^2/solver.h^2 * neighbours_in_domain(i,j,G,solver.len , solver.width) - 2) 1]
    end
#+end_src


initialized as
\[ (\zeta^n, \psi^n)^{T} =
\left(\begin{smallmatrix}
\frac{\phi_{ij}^{n}}{\Delta t}\\
W'(\phi_{ij}^n) - 2\phi_{ij}^n
\end{smallmatrix}
\right)
\]

#+begin_src julia :tangle utils.jl :eval never
function set_xi_and_psi!(solver::multi_solver)
    xi_init(x) = x / solver.dt
    psi_init(x) = solver.W_prime(x) - 2 * x
    solver.xi[2:end-1, 2:end-1] = xi_init.(solver.phase[2:end-1,2:end-1])
    solver.psi[2:end-1, 2:end-1] = psi_init.(solver.phase[2:end-1,2:end-1])
    return nothing
end

#+end_src

the algorithm is then defined as:
# #+caption: FAS Multigrid v-cycle as defined by [cite:@SHIN20117441]

Wherein SMOOTH consists of point-wise Gauß Seidel Relaxation, by solving /L/ for \( \overline{\phi} ,\overline{\mu} \) with the initial guess for \( \zeta^n , \psi^n \).
** SMOOTH Operator
\begin{align}
SMOOTH
\end{align}
and is implemented as:
#+name:SMOOTH
#+begin_src julia :tangle multisolver.jl :eval never
function SMOOTH!(
    solver::multi_solver,
    iterations,
    adaptive
)
    for k = 1:iterations
        old_phase = copy(solver.phase)
        for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)
            coefmatrix =
                [
                    (1/solver.dt) (bordernumber/solver.h^2);
                    (-1*(2+(solver.epsilon^2/solver.h^2)*bordernumber)) 1
                ]


            b =
                [
                    (
                        solver.xi[i, j]
                        +
                        discrete_G_weigted_neigbour_sum(
                            i, j, solver.potential, G, solver.len, solver.width
                        )
                        /
                        solver.h^2
                    ),
                    (
                        solver.psi[i, j]
                        -
                        (solver.epsilon^2 / solver.h^2)
                        *
                        discrete_G_weigted_neigbour_sum(
                            i, j, solver.phase, G, solver.len, solver.width
                        )
                    )
                ]

            res = coefmatrix \ b
            solver.phase[i, j] = res[1]
            solver.potential[i, j] = res[2]

        end

        if adaptive && LinearAlgebra.norm(old_phase - solver.phase) < 1e-8
            #println("SMOOTH terminated at $(k) succesfully")
            break
        end
    end
end
#+end_src

#+begin_src julia :results file graphics  :file smooth.svg :noweb strip-export :async t :exports results :output-dir images :session jl
using Plots
using LaTeXStrings
using LinearAlgebra
include("utils.jl")
<<testdata>>
<<SMOOTH>>
M = testdata(256, 20 , 40, 2);
phase = zeros(size(M) .+ 2);
phase[2:end-1,2:end-1] = M;
mu = copy(phase);
W_prime(x) = -x * (1-x^2)
solver = multi_solver(
    phase ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    8e-3 ,1e-3 , 1e-3 ,
    W_prime ,
    size(M , 1) , size(M , 2) )
set_xi_and_psi!(solver)
SMOOTH!(solver, 2, true);
p = heatmap(solver.phase, aspect_ratio=:equal);
savefig(p,"images/smooth.svg")
#+end_src

#+RESULTS:
[[file:images/smooth.svg]]

** v-cycle
The v-cycle of a two grid method  using pre and post smothing is then stated by
#+begin_src julia :tangle multisolver.jl :eval never
function v_cycle(grid::Array{multi_solver}, level)

    solver = grid[level]
    SMOOTH!(solver, 400, true)
    #println("Finished pre SMOOTHing")

    # extract (d,r) as array operations

    d = zeros(size(solver.phase))
    r = zeros(size(solver.phase))

    for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]
        d[I], r[I] = [solver.xi[I], solver.psi[I]] .- L(solver, I.I..., solver.phase[I], solver.potential[I])
    end

    # print(f"Max derivation d: {np.linalg.norm(d)}")
    # print(f"Max derivation r: {np.linalg.norm(r)}")
    restrict_solver!(grid[level], grid[level+1])
    solver = grid[level+1]
    solution = deepcopy(solver)

d_large = restrict(d, G)
r_large = restrict(r, G)

#println(" d $(norm(d_large))")
#println(" r $(norm(r_large))")

u_large = zeros(size(d_large))
v_large = zeros(size(d_large))

    #TODO short newton iteration for
    for i = 1:300
        for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]

            diffrence = L(solution, I.I..., solution.phase[I], solution.potential[I]) .- [d_large[I], r_large[I]] .- L(solver, I.I..., solver.phase[I], solver.potential[I])
            #diffrence = collect(L(solution, I.I...)) .- collect(L(solver, I.I...))
            #diffrence = [d_large[I] , r_large[I]]

            local ret = dL(solution, I.I...) \ diffrence

            u_large[I] = ret[1]
            v_large[I] = ret[2]
        end
        solution.phase .-= u_large
        solution.potential .-= v_large
    end
    #println("Finished  largegrid")

    u_large = solver.phase .- solution.phase
    v_large = solver.potential .- solution.potential

    solver = grid[level]

    solver.phase .+= prolong(u_large , G)
    solver.potential .+= prolong(v_large, G)
    # smooth again:
    SMOOTH!(solver, 800, true)
    #println("Finished post SMOOTHing")
end
#+end_src
Sol let us have a look at how the internals look in the first iteration
#+begin_src julia-vterm :results file graphics  :file v_cycle.svg :noweb strip-export :async t :exports results :output-dir images  :tangle plot.jl :session jl
cd("/home/jon/Projects/julia_tst/")
include("/home/jon/Projects/julia_tst/utils.jl")
include("/home/jon/Projects/julia_tst/multisolver.jl")
using Plots
using LinearAlgebra
M = testdata(64, 10, 15, 2)

testgrd = testgrid(M, 2)
p0 = heatmap(testgrd[1].phase, title="Initial State");
solver = testgrd[1]
set_xi_and_psi!(solver)
SMOOTH!(solver, 400, true);
p1 = heatmap(solver.phase, title="After Pre Smoothing");


d = zeros(size(solver.phase))
r = zeros(size(solver.phase))

for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]
    d[I], r[I] = [solver.xi[I], solver.psi[I]] .- L(solver, I.I..., solver.phase[I] , solver.potential[I])
end

p2 = heatmap(d, title="Phase Residuals");
level = 1

restrict_solver!(testgrd[level], testgrd[level+1])
solver =testgrd[level+1]
solution = deepcopy(solver)



d_large = restrict(d, G)
r_large = restrict(r, G)

println(" d $(norm(d_large))")
println(" r $(norm(r_large))")

u_large = zeros(size(d_large))
v_large = zeros(size(d_large))


f(phi , mu , I)  = L(solution, I.I..., phi, mu) .- [d_large[I], r_large[I]] .- L(solver, I.I... , solver.phase[I] , solver.potential[I])

for i = 1:300
    for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]


        diffrence = L(solution, I.I..., solution.phase[I], solution.potential[I]) .- [d_large[I], r_large[I]] .- L(solver, I.I... , solver.phase[I] , solver.potential[I])
        #diffrence = collect(L(solution, I.I...)) .- collect(L(solver, I.I...))
        #diffrence = [d_large[I] , r_large[I]]

        local ret = dL(solution , I.I...) \ diffrence
        #if I == CartesianIndex(2,2)  println("Diffrence: $(diffrence) , Ret: $(ret)") end

        u_large[I] = ret[1]
        v_large[I] = ret[2]
    end
    solution.phase .-= u_large
    solution.potential .-= v_large
end

#u_large = solution.phase - solver.phase

# u_large , v_large = (solver.phase , solver.potential) .- (solution.phase , solution.potential)
p3 = heatmap(u_large, title="error $(norm(u_large)) ")
p = plot(p0, p1, p2,p3, layout=(2, 2));
savefig(p, "images/v_cycle.svg")
#+end_src

#+RESULTS:
[[file:images/v_cycle.svg]]

and a few iterations of the V-cycle exhibit the following behaviour:

#+begin_src julia-vterm :results file graphics  :file iteration.gif :noweb strip-export :async t :exports results :output-dir images  :tangle plot.jl :session jl :eval never-export
include("/home/jon/Projects/julia_tst/utils.jl")
include("/home/jon/Projects/julia_tst/multisolver.jl")
using Plots
using LinearAlgebra
using ProgressBars
M = testdata(64, 1, 20 , 2)

testgrd = testgrid(M, 2)
solver = testgrd[1]
set_xi_and_psi!(solver)

pbar = ProgressBar(total = 1000)

anim = @animate for i in 1:100
    for j in 1:10
        v_cycle(testgrd, 1)
        update(pbar)
        end
    set_xi_and_psi!(testgrd[1])
    heatmap(testgrd[1].phase , clim =(-1,1) , framestyle=:none )
end
gif(anim , "images/iteration.gif" , fps = 10)
#+end_src

#+RESULTS:
[[file:images/iteration.gif]]

* Relaxed Problem
In effort to decrease the order of complexity, the following relaxation to the classical Cahn Hillard Equation is proposed:
\begin{align*}
\partial_t \phi^\alpha  &= \Delta \mu \\
\mu &= \varepsilon ^2(c^\alpha - \phi^\alpha) + W'(\phi)
\end{align*}
that in turn requires solving an additional PDE each time-step to calculate \(c\).
 \( c \) is the solution of the following elliptical PDE
\begin{align*}
- \Delta c^\alpha  + \alpha c^a &= \alpha \phi ^\alpha
\end{align*}

** TODO relaxed operators:
the multi-grid solver proposed earlier is then adapted to the relaxed Problem by replacing the differential operators by their discrete counterparts as defined in [[eq:discretization]]
and expanding them
*** L Relaxed
for the reformulation of the iteration in terms of Operator \(L\) then follows:
\begin{align*}
L
\begin{pmatrix}
(\phi ^{n+1})^\alpha \\
\mu^{n+1}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{(\phi^{n+1,m}_{ij})^\alpha}{\Delta t} - \nabla _d \cdot (G_{ji} \nabla _d \mu^{n + \frac{1}{2},m}_{ji}) \\
\varepsilon ^2 \alpha (c^\alpha - (\phi^{n+1,m}_{ij})^\alpha) - 2(\phi ^{n+1,m}_{ij})^\alpha -\mu^{n + \frac{1}{2},m}_{ji}
\end{pmatrix}
\end{align*}
*** SMOOTH
and correspondingly the SMOOTH operation expands to:
\begin{align*}
SMOOTH( (\phi^{n+1,m}_{ij})^\alpha, \mu^{n + \frac{1}{2},m}_{ji}, L_h , \zeta ^n , \psi ^n )
\end{align*}

#+name: eq:discrete_relaxed_smooth
\begin{align*}
  \frac{1}{h^2}\left(G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}\right)\overline{\mu}^{n + \frac{1}{2},m}_{ji} &=
  \frac{(\phi ^{n+1,m}_{ij})^\alpha}{\Delta t} - \zeta^n_{ij} \\
&- \frac{1}{h^2} (\\
&G_{i+\frac{1}{2}j} \mu^{n + \frac{1}{2},m}_{i+1j}\\
&+  G_{i-\frac{1}{2}j} \mu^{n + \frac{1}{2},m}_{i-1j} \\
&+ G_{ij+\frac{1}{2}}  \mu^{n + \frac{1}{2},m}_{ij+1} \\
&+ G_{ij-\frac{1}{2}} \mu^{n + \frac{1}{2},m}_{ij-1} \\
& ) \\
\end{align*}

\begin{align*}
 \varepsilon ^2 \alpha (\overline{\phi} ^{n+1,m}_{ij})^\alpha + 2 \phi ^{n+1,m}_{ij} &= \varepsilon ^2 \alpha c^\alpha  -\mu^{n + \frac{1}{2},m}_{ji}  - \psi_{ij}
\end{align*}
**** Proposal1
Since the resulting system no longer is linear, (albeit simpler in Dimension), we propose a newton method to solve second equation (in conjunction with the first one) hopefully solving this converges faster than the original multiple SMOOTH Iterations.
 The iteration solves for \( (\phi ^{n+1,m}_{ij})^\alpha = x \) as free variable. Therefore, it follows for \( F(x) \)
\begin{align*}
F(x)  &= \varepsilon ^2 x^\alpha + 2x - \varepsilon^2 c^\alpha  + y + \psi_{ij} \\
y &= \frac{x}{\Delta t} - \zeta^n_{ij} \\
&- \frac{1}{h^2}\left(G_{i+\frac{1}{2}j} \mu^{n + \frac{1}{2},m}_{i+1j} +  G_{i-1j} \mu^{n + \frac{1}{2},m}_{i-1j} + G_{ij+1}  \mu^{n + \frac{1}{2},m}_{ij+1} + G_{ij-1} \mu^{n + \frac{1}{2},m}_{ij-1}\right) \\
&\cdot  \left(G_{i+1j} + G_{i-1j} + G_{ij+1} + G_{ij-1}\right)^{-1} \\
\end{align*}
And the derivative for the iteration is
        \begin{align*}
\frac{d}{dx} F(x)&= \alpha \varepsilon^2 x^{\alpha-1} + 2 + \frac{d}{dx} y  \\
\frac{d}{dx} y  &= \frac{1}{\Delta t}
\end{align*}
**** Proposal2
solve analytically for \( \overline{\mu_{ij}^{n+1,m}}  \)  and \( (\overline{\phi_{ij}^{n+1,m}})^{\alpha} \). This was not done in the original paper as the there required System of linear equations was solved numerically. The relaxation simplifies the it to one dimension, and enables analytical solutions:

Let \( \Sigma_G \mu_{ij} = G_{i+\frac{1}{2}j} \mu^{n + \frac{1}{2},m}_{i+1j} +  G_{i-\frac{1}{2}j} \mu^{n + \frac{1}{2},m}_{i-1j} + G_{ij+\frac{1}{2}}  \mu^{n + \frac{1}{2},m}_{ij+1} + G_{ij-\frac{1}{2}} \mu^{n + \frac{1}{2},m}_{ij-1} \) and \( \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}} \). Then [[eq:discrete_relaxed_smooth]] solves as
\begin{align*}
\varepsilon^2 \alpha(\phi^\alpha) + 2\phi^\alpha &= \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G} (\frac{\phi^\alpha}{\Delta t} - \zeta^n_{ij} - \frac{1}{h^2} \Sigma_G \mu_{ij}) - \psi_{ij}
\end{align*}
\( \implies \)
\begin{align*}
\varepsilon^2\alpha (\phi^\alpha) + 2\phi^\alpha + \frac{h^2}{\Sigma_G}\frac{\phi^\alpha}{\Delta t} &= \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G} (- \zeta^n_{ij} - \frac{1}{h^2} \Sigma_G \mu_{ij}) - \psi_{ij}
\end{align*}
\( \implies \)
\begin{align*}
(\varepsilon^2 \alpha + 2 + \frac{h^2}{\Sigma_G \Delta t}) \phi^\alpha = \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G}(- \zeta^n_{ij} - \frac{\Sigma_G \mu_{ij}}{h^2} ) -\psi_{ij}
\end{align*}

** Elliptical PDE:
on order to solve the relaxed CH Equation the following PDE as to be solved in Each additional time step:
or in terms of the characteristic function:
\begin{align*}
- \nabla \cdot  (G \nabla c^\alpha) + \alpha c^\alpha  = \alpha \phi ^\alpha
\end{align*}
Similarly to the first solver this PDE is solved with a finite difference scheme using the same discretisations as before:
*** Discretization
the Discretization of the PDE expands the differential opperators in the same way and proposes an equivalent scheme for solving.
\begin{align*}
- \nabla_d \cdot  (G_{ij} \nabla_d c_{ij}^\alpha) + \alpha  c_{ij}^\alpha &= \alpha \phi_{ij}^\alpha
\end{align*}
\( \implies \)
\begin{align*}
- (\frac{1}{h}(G_{i+\frac{1}{2}j} \nabla c^\alpha_{i+\frac{1}{2}j} + G_{ij+\frac{1}{2}} \nabla c^\alpha_{ij+\frac{1}{2}}) &  \\
- (G_{i-\frac{1}{2}j} \nabla c^\alpha_{i-\frac{1}{2}j} + G_{ij-\frac{1}{2}} \nabla c^\alpha_{ij-\frac{1}{2}})) + \alpha  c_{ij}^\alpha   &= \alpha  \phi_{ij}^\alpha
\end{align*}
\( \implies \)
\begin{align*}
- \frac{1}{h^2} ( G_{i+\frac{1}{2}j}(c_{i+1j}^\alpha - c_{ij}^\alpha) & \\
+G_{ij+\frac{1}{2}}(c_{ij+1}^\alpha - c_{ij}^\alpha) & \\
+G_{i-\frac{1}{2}j}(c_{i-1j}^\alpha - c_{ij}^\alpha)& \\
+G_{ij-\frac{1}{2}}(c_{ij-1}^\alpha - c_{ij}^\alpha)) + \alpha  c_{ij}^\alpha &=\alpha  \phi_{ij}^\alpha
\end{align*}


As before we abbreviate \(  \Sigma_G c^\alpha_{ij} = G_{i+\frac{1}{2}j} c^\alpha_{i+1j} +  G_{i-\frac{1}{2}j} c^\alpha_{i-1j} + G_{ij+\frac{1}{2}}  c^\alpha_{ij+1} + G_{ij-\frac{1}{2}} c^\alpha_{ij-1}  \) and \(  \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}  \). Then the discrete elyptical PDE can be stated as:
#+name: eq:discrete_elyps
\begin{align}
-\frac{ \Sigma_G c^\alpha_{ij}}{h^2} + \frac{\Sigma_G}{h^2} c^\alpha_{ij} + \alpha c^\alpha_{ij} &= \alpha\phi^\alpha_{ij}
\end{align}

**** Proposal1 Newton Solver
And then we propose a simple newton Iteration to solve  [[eq:discrete_elyps]]  for \( x = c^\alpha_{ij} \):
Let \( F, dF \) be:
\begin{align*}
F(x) &= - \frac{\Sigma_Gc^\alpha_{ij}}{h^2} + \frac{\Sigma_G}{h^2}  x + \alpha x  - \alpha \phi_{ij}^\alpha
\end{align*}
and \( dF(x) \)

\begin{align*}
dF(x) &= - \frac{\Sigma_G}{h^2}    + \alpha
\end{align*}
the implementation then is the following:

as input we use :

**** Proposal2 Analytical solver
solving [[eq:discrete_elyps]] for \(c_{ij}^\alpha \) then results in.
\begin{align*}
\left( \frac{\Sigma_{G}}{h^2} + \alpha \right)c_{ij}^{\alpha} = \alpha\phi^{\alpha}_{ij} + \frac{\Sigma_G c_{ij}^{\alpha}}{h^2}
\end{align*}
and can be translated to code as follows

**** Proposal 4
as the solver still exhibits unexpected behaviour, ie. it doesn't seem to converge wit higher iterations, we propose a relaxation by interpolating the new value of \(  c_{ij}^\alpha \) with the old one

* References
#+PRINT_BIBLIOGRAPHY:
#  LocalWords:  Discretization
