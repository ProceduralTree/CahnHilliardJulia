<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-14 Thu 18:46 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bachelor Thesis</title>
<meta name="author" content="Jonathan Ulmer" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  pre.src-C\+\+:before { content: 'C++'; }
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Bachelor Thesis</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8bd9a2e">1. Cahn-Hilliard equation</a></li>
<li><a href="#org3095c05">2. Baseline multi-grid solver:</a></li>
<li><a href="#org0992d0b">3. Numerical Evaluation</a></li>
<li><a href="#orgf82f796">4. Relaxed Problem</a></li>
<li><a href="#org0d3776f">5. References</a></li>
</ul>
</div>
</div>
<div id="outline-container-org8bd9a2e" class="outline-2">
<h2 id="org8bd9a2e"><span class="section-number-2">1.</span> Cahn-Hilliard equation</h2>
<div class="outline-text-2" id="text-1">
<p>
is a partial differential equation (PDE) solving the state of a two-phase fluid(<a href="#citeproc_bib_item_2">Wu 2022</a>). The form of the Cahn-Hilliard (CH) equation used in this thesis is:
</p>
\begin{equation}
\label{org8d07176}
\begin{aligned}
\phi _t(x,t) &=  \nabla \cdot(M(\phi)\nabla\mu) \\
\mu &= - \varepsilon^2 \Delta\phi  + W'(\phi)
\end{aligned}
\end{equation}
<p>
where \( \phi\) is a phase-field variable representing the different states of the fluids through an interval \(I=[-1,1] \)
</p>
\begin{align*}
\phi &=
\begin{cases}
1 & \phi = \text{phase 1} \\
-1 & \phi =\text{ phase 2}
\end{cases}
\end{align*}

<p>
\(\varepsilon > 0 \) is a  constant correlated with boundary thickness.
and \(\mu\) is the chemical potential(<a href="#citeproc_bib_item_2">Wu 2022</a>)
</p>

<p>
In this thesis we assume \(M(\phi) = 1 \), simplifying the CH equation used in (<a href="#citeproc_bib_item_2">Wu 2022</a>) (<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>)
</p>

<p>
The advantages of the CH Approach as compared to traditional boundary coupling, are for example: &ldquo;explicit tracking of the interface&rdquo; (<a href="#citeproc_bib_item_2">Wu 2022</a>), as well as &ldquo;evolution of complex geometries and topological changes [&#x2026;] in a natural way&rdquo; (<a href="#citeproc_bib_item_2">Wu 2022</a>).
In practice it enables linear interpolation between different formulas on different phases.
</p>
</div>
<div id="outline-container-orga643163" class="outline-3">
<h3 id="orga643163"><span class="section-number-3">1.1.</span> Derivation from paper</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-orgc175245" class="outline-4">
<h4 id="orgc175245"><span class="section-number-4">1.1.1.</span> Free energy</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
The Cahn Hillard Equations can be motivated Using a <b>Ginzburg Landau</b> type free energy equation:
</p>
\begin{align*}
\label{org12af922}
E^{\text{bulk}} = \int_{\Omega} \frac{\varepsilon^2}{2} |\nabla \phi |^2 + W(\phi) \, dx
\end{align*}
<p>
where \(W(\phi) \) denotes the (Helmholtz) free energy density of mixing.&ldquo;&rdquo; (<a href="#citeproc_bib_item_2">Wu 2022</a>) and we approximate it in further calculations as \(W(\phi) = \frac{(1-\phi ^2)^2}{4}\) like in (<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>)
</p>

<p>
The chemical potential then follows as derivative of Energy in respect to time.
</p>
\begin{align*}
 \mu &= \frac{\delta E_{bulk}(\phi)}{\delta \phi} = -\varepsilon^2 \Delta \phi + W'(\phi)
\end{align*}
</div>
</div>
<div id="outline-container-org59b8383" class="outline-4">
<h4 id="org59b8383"><span class="section-number-4">1.1.2.</span> <span class="todo TODO">TODO</span> Derivation by mass balance</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
We motivate the Cahn Hillard equation as follows:
consider
</p>
\begin{equation}
\label{orgea9f9db}
    \partial_t \phi + \nabla \cdot J = 0
\end{equation}
<p>
where <b>J</b> is mass flux. \eqref{orgea9f9db} then states that the change in mass balances the change of the phase field.
Using the no-flux boundary conditions:
</p>
\begin{align}
J \cdot n &= 0 & \partial\Omega &\times (0,T)\\
\partial_n\phi &= 0 & \partial\Omega &\times (0,T)
\end{align}
<p>
conservation of mass follows see(<a href="#citeproc_bib_item_2">Wu 2022</a>).
</p>
\begin{equation}
\label{orgb385939}
\begin{aligned}
\frac{d}{dt}\int_{\Omega}\phi&=\int_{\Omega}\frac{\partial \phi}{\partial t} dV \\
&= - \int_{\Omega} \nabla \cdot J \ dV\\
&= - \int_{\partial\Omega}  J \cdot n  \ dA \\
&= 0
\end{aligned}
\end{equation}

<p>
Using:
</p>
\begin{align}
J &= - \nabla \mu
\end{align}
<p>
which conceptionally sets mass flux to equalize the potential energy gradient, leads to the formulation of the CH equations as stated above. Additionally, the boundary conditions evaluate to:
</p>
\begin{equation}
\label{org6f45652}
\begin{aligned}
 - \nabla \mu &= 0 \\
\partial_n \phi &= 0
\end{aligned}
\end{equation}
<p>
i.e. no flow leaves and potential on the border doesn&rsquo;t change.
Then for \(\phi \) then follows:
</p>
\begin{align*}
\frac{d}{dt}E^{bulk}(\phi(t)) &= \int_{\Omega} ( \varepsilon^2 \nabla \phi \cdot \nabla \partial_t \phi + W'(\phi) \partial_t \phi) \ d x \\
&=\int_{\Omega} (\varepsilon^2\nabla\phi + W'(\phi))\partial_t\phi \ dx\\
&=\int_{\Omega} \mu \partial_t \phi \ dx\\
&= \int_{\Omega} \mu \cdot \Delta\mu \\
&= -\int_{\Omega} \nabla\mu \cdot \nabla\mu + \int_{\partial\Omega} \mu \nabla\phi_t \cdot n \ dS \\
&\stackrel{\partial_n\phi = 0}{=} - \int_{ \Omega } |\nabla \mu|^2 \ d x, & \forall t \in (0,T)
\end{align*}
<p>
hence the Free Energy is decreasing in time.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org3095c05" class="outline-2">
<h2 id="org3095c05"><span class="section-number-2">2.</span> Baseline multi-grid solver:</h2>
<div class="outline-text-2" id="text-2">
<p>
As baseline for further experiments we use a two-grid method based on finite differences as defined in(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>).
</p>
</div>
<div id="outline-container-orgf7f31ed" class="outline-3">
<h3 id="orgf7f31ed"><span class="section-number-3">2.1.</span> Discretization:</h3>
<div class="outline-text-3" id="text-2-1">
<p>
it discretizes the phase-field ,\( \phi \), and chemical potential ,\( \mu \), into grid-wise functions \(\phi_{ij}, \mu_{ij} \) and defines the partial derivatives \( D_xf_{ij}, \ D_yf_{ij} \) using differential quotients:
</p>
\begin{align}
D_xf_{i+\frac{1}{2} j} &= \frac{f_{i+1j} - f_{ij}}{h} & D_yf_{ij+\frac{1}{2}} &= \frac{f_{ij+1} - f_{ij}}{h}
\end{align}
<p>
for \( \nabla f, \Delta f \) then follows:
</p>
\begin{align*}
\label{org0dbbf07}
\nabla_d f_{ij} &= (D_x f_{i+1j} , \ D_y f_{ij+1}) \\
 \Delta_d f_{ij} &= \frac{D_x f_{i+\frac{1}{2}j} -  D_x f_{i-\frac{1}{2}j} + D_y f_{ij+\frac{1}{2}} - D_y f_{ij-\frac{1}{2}}}{h} = \nabla_d \cdot  \nabla_d f_{ij}
\end{align*}
<p>
the authors(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) further adapt the discretized phase-field by the characteristic function of the domain \( \Omega\):
</p>
\begin{align*}
G(x,y) &=
\begin{cases}
1, & (x,y) \in  \Omega \\
0, & (x,y) \not\in  \Omega
\end{cases}
\end{align*}

<p>
To simplify notation we use the following abbreviations:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Math</td>
<td class="org-left">Code</td>
</tr>

<tr>
<td class="org-left">\(  \Sigma_G f_{ij} = G_{i+\frac{1}{2}j} f^{n + \frac{1}{2},m}_{i+1j} +  G_{i-\frac{1}{2}j} f^{n + \frac{1}{2},m}_{i-1j} + G_{ij+\frac{1}{2}}  f^{n + \frac{1}{2},m}_{ij+1} + G_{ij-\frac{1}{2}} f^{n + \frac{1}{2},m}_{ij-1}  \)</td>
<td class="org-left"><code>discrete_weigted_neigbour_sum(i,j,...)</code></td>
</tr>

<tr>
<td class="org-left">\(  \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}  \)</td>
<td class="org-left"><code>neighbours_in_domain(i,j,G)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">neighbours_in_domain</span>(i, j, G, len, width)
    (
        G(i <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>, j, len, width)
        <span style="color: #bb9200;">+</span> G(i <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>, j, len, width)
        <span style="color: #bb9200;">+</span> G(i, j <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>, len, width)
        <span style="color: #bb9200;">+</span> G(i, j <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>, len, width)
    )

<span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">discrete_G_weigted_neigbour_sum</span>(i, j, arr, G, len, width)
    (
        G(i <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>, j, len, width) <span style="color: #bb9200;">*</span> arr[i<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>, j]
        <span style="color: #bb9200;">+</span> G(i <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>, j, len, width) <span style="color: #bb9200;">*</span> arr[i<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>, j]
        <span style="color: #bb9200;">+</span> G(i, j <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>, len, width) <span style="color: #bb9200;">*</span> arr[i, j<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>]
        <span style="color: #bb9200;">+</span> G(i, j <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>, len, width) <span style="color: #bb9200;">*</span> arr[i, j<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>]
    )
<span style="color: #8959a8;">end</span>
</pre>
</div>

<p>
We can then write the, often occurring, modified Laplacian \( \nabla_d (G \nabla_df_{ij}) \) as
</p>
\begin{align*}
\nabla_{d}(G \nabla_df_{ij}) &= \frac{\Sigma_Gf_{ij} - \Sigma_G\cdot f_{ij}}{h^2}
\end{align*}

<p>
To account for no-flux boundary conditions and arbitrary shaped domains.
The authors (<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) then define the discrete CH equation adapted for the domain, as:
</p>
\begin{equation}
\label{org26094ca}
\begin{aligned}
\frac{\phi_{ij}^{n+1} - \phi_{ij}^n}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2}} )  \\
 \mu_{ij}^{n+\frac{1}{2}} &= 2\phi_{ij}^{n+1} - \varepsilon^2  \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1} ) + W'(\phi_{ij}^n) - 2\phi _{ij}^n
\end{aligned}
\end{equation}
<p>
and derive a numerical scheme from these implicit equations.
</p>
</div>
</div>
<div id="outline-container-orgb215f29" class="outline-3">
<h3 id="orgb215f29"><span class="section-number-3">2.2.</span> Adaptations to the simplified problem</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Even tough this work uses rectangular domains, we simplify the adaptation of the algorithm by the domain indicator function, as well as 0 padding, in order to correctly include the boundary conditions of the CH equation.
Therefore, the internal representation of the adapted algorithm considers phase-field ,\( \phi \), and chemical potential field ,\( \mu \),  as two-dimensional arrays with the shape \( (N_x + 2 , N_y + 2) \) in order to accommodate padding. Where N<sub>x</sub> and N<sub>y</sub> are the number of steps in x-/y-direction, respectively.
Hence, we define the discrete domain function as:
</p>
\begin{align*}
G_{ij} &=
\begin{cases}
1, & (i,j) \in  [2,N_x+1] \times  [2,N_y+1] \\
0, & \text{else}
\end{cases}
\end{align*}

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">G</span>(i, j, len, width)
    <span style="color: #8959a8;">if</span> <span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">&lt;=</span> i <span style="color: #bb9200;">&lt;=</span> len <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">1</span> <span style="color: #bb9200;">&amp;&amp;</span> <span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">&lt;=</span> j <span style="color: #bb9200;">&lt;=</span> width <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">1.0</span>
    <span style="color: #8959a8;">else</span>
        <span style="color: #8959a8;">return</span> <span style="color: #f5871f; font-weight: bold;">0.0</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf7019ad" class="outline-3">
<h3 id="orgf7019ad"><span class="section-number-3">2.3.</span> PDE as Operator</h3>
<div class="outline-text-3" id="text-2-3">
<p>
We derive the iteration operator \( L(\phi^{n+1} , \mu^{n+\frac{1}{2}}) = (\zeta^n ,\psi^n) \)as in(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>).
</p>
\begin{align*}
L
\begin{pmatrix}
\phi^{n+1}_{ij} \\
\mu^{n+\frac{1}{2}}_{ij}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi^{n+1}_{ij}}{\Delta t} - \nabla _d \cdot  ( G_{ij} \nabla _d \mu^{n+\frac{1}{2}}_{ij} ) \\
\varepsilon^2 \nabla _d \cdot  (G \nabla_d \phi_{ij}^{n+1}) - 2\phi_{ij}^{n+1} + \mu_{ij}^{n+\frac{1}{2}}
\end{pmatrix}
\end{align*}
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">L</span>(solver<span style="color: #bb9200;">::multi_solver</span>,i,j , phi , mu)
    xi = solver.phase[i, j] <span style="color: #bb9200;">/</span> solver.dt <span style="color: #bb9200;">-</span>
         (discrete_G_weigted_neigbour_sum(i, j, solver.potential, G, solver.len, solver.width)
          <span style="color: #bb9200;">-</span>
          neighbours_in_domain(i, j, G, solver.len, solver.width) <span style="color: #bb9200;">*</span> mu )<span style="color: #bb9200;">/</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
    psi = solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span>
          (discrete_G_weigted_neigbour_sum(i, j, solver.phase, G, solver.len, solver.width)
           <span style="color: #bb9200;">-</span>
           neighbours_in_domain(i, j, G, solver.len, solver.width) <span style="color: #bb9200;">*</span> phi) <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> phi <span style="color: #bb9200;">+</span> mu
    <span style="color: #8959a8;">return</span> [xi, psi]
<span style="color: #8959a8;">end</span>
</pre>
</div>
<p>
This operator follows from \eqref{org26094ca} by separating implicit and explicit terms \( L \) and   \( (\zeta^n_{ij} , \psi^n_{ij})^T \), respectively.
</p>
\begin{align*}
\begin{pmatrix}
\zeta^n
 \\
\psi^n
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi_{ij}^{n}}{\Delta t}\\
W'(\phi_{ij}^n) - 2\phi_{ij}^n
\end{pmatrix}
\end{align*}
<p>
Due to being explicit, we know everything needed to calculate \( (\zeta^n_{ij} , \psi^n_{ij})^T \). We compute those values  once for every time step, and store them in the solver.
</p>
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">set_xi_and_psi!</span>(solver<span style="color: #bb9200;">::T</span>) <span style="color: #8959a8;">where</span> T <span style="color: #bb9200;">&lt;:</span> <span style="color: #bb9200;">Union</span>{multi_solver , relaxed_multi_solver}
    <span style="color: #4271ae;">xi_init</span>(x) = x <span style="color: #bb9200;">/</span> solver.dt
    <span style="color: #4271ae;">psi_init</span>(x) = solver.W_prime(x) <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> x
    solver.xi[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>] = xi_init.(solver.phase[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>])
    solver.psi[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>] = psi_init.(solver.phase[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>])
    <span style="color: #8959a8;">return</span> <span style="color: #f5871f;">nothing</span>
<span style="color: #8959a8;">end</span>

</pre>
</div>

<p>
Furthermore, as it enables a Newton iteration, we derive its derivative with respect to the current grid point \( (\phi^{n+1}_{ij} , \mu^{n+\frac{1}{2}}_{ij})^{T} \):
</p>

\begin{align*}
DL\begin{pmatrix}
\phi \\
\mu
\end{pmatrix} &= \begin{pmatrix}
\frac{1}{\Delta t} & \frac{1}{h^2}\Sigma_{G}  \\
-\frac{\varepsilon^2}{h^2}\Sigma_{G} - 2 & 1
\end{pmatrix}
\end{align*}
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">dL</span>(solver<span style="color: #bb9200;">::multi_solver</span> , i , j)
    <span style="color: #8959a8;">return</span> [ (<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>solver.dt) (<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>neighbours_in_domain(i,j,G,solver.len , solver.width));
             (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span>solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> neighbours_in_domain(i,j,G,solver.len , solver.width) <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span>) <span style="color: #f5871f; font-weight: bold;">1</span>]
    <span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgbb1047e" class="outline-3">
<h3 id="orgbb1047e"><span class="section-number-3">2.4.</span> V-cycle approach</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The numerical method proposed in (<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) consists of a V-cycle multi-grid method derived from previously stated operators. Specificly we use a two-grid implementation consisting of
</p>
<ol class="org-ol">
<li>a Gauß-Seidel relaxation for smoothing.</li>
<li>restriction and prolongation methods between grids \(  h \leftrightarrow H  \).</li>
<li>a Newton iteration to solve \( L(x,y)_H = L(\bar{x} , \bar{y}) + (d_h , r_h) \).</li>
</ol>

<p>
The V-cycle of a two-grid method using pre and post smoothing is then stated by:
</p>
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">v_cycle!</span>(grid<span style="color: #bb9200;">::Array</span>{T}, level) <span style="color: #8959a8;">where</span> T <span style="color: #bb9200;">&lt;:</span> <span style="color: #bb9200;">Union</span>{multi_solver , relaxed_multi_solver}

    solver = grid[level]
    <span style="color: #8e908c;">#</span><span style="color: #8e908c;">pre SMOOTHing:</span>
    SMOOTH!(solver, <span style="color: #f5871f; font-weight: bold;">400</span>, <span style="color: #f5871f;">true</span>)

    d = zeros(size(solver.phase))
    r = zeros(size(solver.phase))

    <span style="color: #8e908c;"># </span><span style="color: #8e908c;">calculate error between L and expected values</span>
    <span style="color: #8959a8;">for</span> I <span style="color: #8959a8;">in</span> CartesianIndices(solver.phase)[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>]
        d[I], r[I] = [solver.xi[I], solver.psi[I]] .<span style="color: #bb9200;">-</span> L(solver, I.I..., solver.phase[I], solver.potential[I])
    <span style="color: #8959a8;">end</span>

    restrict_solver!(grid[level], grid[level<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>])
    solver = grid[level<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>]
    solution = deepcopy(solver)

    d_large = restrict(d, G)
    r_large = restrict(r, G)


    u_large = zeros(size(d_large))
    v_large = zeros(size(d_large))

    <span style="color: #8e908c;">#</span><span style="color: #8e908c;">Newton Iteration for solving smallgrid</span>
    <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">=</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">300</span>
        <span style="color: #8959a8;">for</span> I <span style="color: #8959a8;">in</span> CartesianIndices(solver.phase)[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>]

            diffrence = L(solution, I.I..., solution.phase[I], solution.potential[I]) .<span style="color: #bb9200;">-</span> [d_large[I], r_large[I]] .<span style="color: #bb9200;">-</span> L(solver, I.I..., solver.phase[I], solver.potential[I])
            <span style="color: #8e908c;">#</span><span style="color: #8e908c;">diffrence = collect(L(solution, I.I...)) .- collect(L(solver, I.I...))</span>
            <span style="color: #8e908c;">#</span><span style="color: #8e908c;">diffrence = [d_large[I] , r_large[I]]</span>

            <span style="color: #8959a8;">local</span> ret = dL(solution, I.I...) <span style="color: #bb9200;">\</span> diffrence

            u_large[I] = ret[<span style="color: #f5871f; font-weight: bold;">1</span>]
            v_large[I] = ret[<span style="color: #f5871f; font-weight: bold;">2</span>]
        <span style="color: #8959a8;">end</span>
        solution.phase .<span style="color: #bb9200;">-=</span> u_large
        solution.potential .<span style="color: #bb9200;">-=</span> v_large
    <span style="color: #8959a8;">end</span>
    u_large = solver.phase .<span style="color: #bb9200;">-</span> solution.phase
    v_large = solver.potential .<span style="color: #bb9200;">-</span> solution.potential

    solver = grid[level]

    solver.phase .<span style="color: #bb9200;">+=</span> prolong(u_large , G)
    solver.potential .<span style="color: #bb9200;">+=</span> prolong(v_large, G)
    SMOOTH!(solver, <span style="color: #f5871f; font-weight: bold;">800</span>, <span style="color: #f5871f;">true</span>)
<span style="color: #8959a8;">end</span>
</pre>
</div>
<p>
So let&rsquo;s take a closer look at the internals, namely the phase field after pre-SMOOTHing \( \bar{\phi} \), the phase residuals of \( \left[ L(\bar{\phi_{ij}}, \bar{\mu_{ij}}) - (\zeta_{ij} , \psi_{ij}) \right]_{ij \in \Omega} \) and the result of the Newton iteration on coarsest level.
</p>

<div id="orgdaea60a" class="figure">
<p><img src="images/v_cycle.svg" alt="v_cycle.svg" class="org-svg" />
</p>
</div>

<p>
After a few iterations, V-cycle exhibits the following behavior:
</p>

<div class="org-src-container">
<pre class="src src-julia-vterm">
set_xi_and_psi!(solver)

pbar = ProgressBar(total = <span style="color: #f5871f; font-weight: bold;">1000</span>)

anim = <span style="color: #4d4d4c; font-weight: bold;">@animate</span> <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">100</span>
    <span style="color: #8959a8;">for</span> j <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">10</span>
        v_cycle!(testgrd, <span style="color: #f5871f; font-weight: bold;">1</span>)
        update(pbar)
        <span style="color: #8959a8;">end</span>
    set_xi_and_psi!(testgrd[<span style="color: #f5871f; font-weight: bold;">1</span>])
    heatmap(testgrd[<span style="color: #f5871f; font-weight: bold;">1</span>].phase , clim =(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">1</span>) , framestyle=<span style="color: #f5871f;">:none</span> )
<span style="color: #8959a8;">end</span>
gif(anim , <span style="color: #718c00;">"images/iteration.gif"</span> , fps = <span style="color: #f5871f; font-weight: bold;">10</span>)
</pre>
</div>


<div id="org556c732" class="figure">
<p><img src="images/iteration.gif" alt="iteration.gif" />
</p>
</div>
</div>
</div>
<div id="outline-container-org376accd" class="outline-3">
<h3 id="org376accd"><span class="section-number-3">2.5.</span> SMOOTH operator</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The authors(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>)derived Gaus-Seidel Smoothing from:
</p>
\begin{align*}
L
\begin{pmatrix}
\phi^{n+1}_{ij} \\
\mu^{n+\frac{1}{2}}_{ij}
\end{pmatrix}
&=
\begin{pmatrix}
\zeta^n_{ij} \\
\psi^n_{ij}
\end{pmatrix}
\end{align*}
<p>
solved for \( \phi , \mu \).
 SMOOTH consists of point-wise Gauß-Seidel relaxation, by solving <i>L</i> for \( \overline{\phi} ,\overline{\mu} \) with the initial guess for \( \zeta^n , \psi^n \).
</p>
\begin{align}
SMOOTH( \phi^{n+1,m}_{ij}, \mu^{n + \frac{1}{2},m}_{ji}, L_h , \zeta^n , \psi^n )
\end{align}
<p>
and we implement it as
</p>
<div class="org-src-container">
<pre class="src src-julia" id="org19f1e4c"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">SMOOTH!</span>(
    solver<span style="color: #bb9200;">::multi_solver</span>,
    iterations,
    adaptive
)
    <span style="color: #8959a8;">for</span> k <span style="color: #8959a8;">=</span> <span style="color: #f5871f; font-weight: bold;">1</span>:iterations
        old_phase = copy(solver.phase)
        <span style="color: #8959a8;">for</span> I <span style="color: #8959a8;">in</span> CartesianIndices(solver.phase)[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)

            coefmatrix = dL(solver, i,j )

            b =
                [
                    (
                        solver.xi[i, j]
                        <span style="color: #bb9200;">+</span>
                        discrete_G_weigted_neigbour_sum(
                            i, j, solver.potential, G, solver.len, solver.width
                        )
                        <span style="color: #bb9200;">/</span>
                        solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
                    ),
                    (
                        solver.psi[i, j]
                        <span style="color: #bb9200;">-</span>
                        (solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">/</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
                        <span style="color: #bb9200;">*</span>
                        discrete_G_weigted_neigbour_sum(
                            i, j, solver.phase, G, solver.len, solver.width
                        )
                    )
                ]

            res = coefmatrix <span style="color: #bb9200;">\</span> b
            solver.phase[i, j] = res[<span style="color: #f5871f; font-weight: bold;">1</span>]
            solver.potential[i, j] = res[<span style="color: #f5871f; font-weight: bold;">2</span>]

        <span style="color: #8959a8;">end</span>

        <span style="color: #8959a8;">if</span> adaptive <span style="color: #bb9200;">&amp;&amp;</span> LinearAlgebra.norm(old_phase <span style="color: #bb9200;">-</span> solver.phase) <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">1e-8</span>
            <span style="color: #8e908c;">#</span><span style="color: #8e908c;">println("SMOOTH terminated at $(k) succesfully")</span>
            <span style="color: #8959a8;">break</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>


<div id="orgb6b7e96" class="figure">
<p><img src="images/smooth.svg" alt="smooth.svg" class="org-svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgfa29f5f" class="outline-3">
<h3 id="orgfa29f5f"><span class="section-number-3">2.6.</span> Test Data:</h3>
<div class="outline-text-3" id="text-2-6">
<p>
For testing and later training we use a multitude of different phase-fields, notably an assortment of randomly placed circles, squares, and arbitrary generated values.
</p>

<table id="orgd3b3166" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Size</th>
<th scope="col" class="org-right">blobs</th>
<th scope="col" class="org-right">blobsize</th>
<th scope="col" class="org-right">norm</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">64</td>
<td class="org-right">10</td>
<td class="org-right">10</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-right">10</td>
<td class="org-right">10</td>
<td class="org-right">100</td>
</tr>

<tr>
<td class="org-right">512</td>
<td class="org-right">20</td>
<td class="org-right">50</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-julia" id="org546e026"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">testdata</span>(gridsize , blobs , radius ,norm)
rngpoints = rand(<span style="color: #f5871f; font-weight: bold;">1</span>:gridsize, <span style="color: #f5871f; font-weight: bold;">2</span>, blobs)
M = zeros(gridsize,gridsize) .<span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">1</span>
<span style="color: #8959a8;">for</span> p <span style="color: #8959a8;">in</span> axes(rngpoints , <span style="color: #f5871f; font-weight: bold;">2</span>)
    point = rngpoints[:, p]
    <span style="color: #8959a8;">for</span> I <span style="color: #8959a8;">in</span> CartesianIndices(M)
        <span style="color: #8959a8;">if</span> (LinearAlgebra.norm(point .<span style="color: #bb9200;">-</span> I.I  , norm) <span style="color: #bb9200;">&lt;</span> radius)
            M[I] = <span style="color: #f5871f; font-weight: bold;">1</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
M
<span style="color: #8959a8;">end</span>
</pre>
</div>


<div id="org69c14a7" class="figure">
<p><img src="testdata.svg" alt="testdata.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 1: </span>Examples of different phase-fields used as the initial condition in this work.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org0992d0b" class="outline-2">
<h2 id="org0992d0b"><span class="section-number-2">3.</span> Numerical Evaluation</h2>
<div class="outline-text-2" id="text-3">
<p>
The analytical CH equation exhibits mass conservation \eqref{orgea9f9db} and a decrease in Energy \( E_{bulk} \) \eqref{org12af922}. Therefore, we use discrete variants of those concepts as necessary conditions for a &ldquo;good&rdquo; solution. Furthermore, since \( E_{bulk} \) is closely correlated with potential Energy \( \mu \), we evaluate this difference as quality of convergence.
</p>
</div>
<div id="outline-container-orga344ef6" class="outline-3">
<h3 id="orga344ef6"><span class="section-number-3">3.1.</span> Energy Evaluations</h3>
<div class="outline-text-3" id="text-3-1">
<p>
As discrete energy measure we use
</p>
\begin{align*}
E^{\text{bulk}} &= \sum_{i,j \in \Omega} \frac{\varepsilon^2}{2} |G\nabla \phi_{ij} |^2 + W\left(\phi_{ij}\right) \, dx \\
&= \sum_{i,j \in \Omega} \frac{\varepsilon^2}{2} G_{i+\frac{1}{2}j}D_x\phi_{i+\frac{1}{2}j} ^2 + G_{ij+\frac{1}{2}}D_y\phi_{ij+\frac{1}{2}}^2  + W\left(\phi_{ij}\right) \, dx \\
\end{align*}
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">bulk_energy</span>(solver<span style="color: #bb9200;">::T</span>) <span style="color: #8959a8;">where</span> T <span style="color: #bb9200;">&lt;:</span> <span style="color: #bb9200;">Union</span>{multi_solver , relaxed_multi_solver}
    energy = <span style="color: #f5871f; font-weight: bold;">0</span>
    dx = CartesianIndex(<span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">0</span>)
    dy = CartesianIndex(<span style="color: #f5871f; font-weight: bold;">0</span>,<span style="color: #f5871f; font-weight: bold;">1</span>)
    <span style="color: #4271ae;">W</span>(x) = <span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span><span style="color: #f5871f; font-weight: bold;">4</span> <span style="color: #bb9200;">*</span> (<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
    <span style="color: #8959a8;">for</span> I <span style="color: #8959a8;">in</span> CartesianIndices(solver.phase)[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>]
        i,j = I.I
        energy <span style="color: #bb9200;">+=</span> solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">/</span> <span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> G(i<span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">0.5</span>,j ,solver.len, solver.width) <span style="color: #bb9200;">*</span> (solver.phase[I<span style="color: #bb9200;">+</span>dx] <span style="color: #bb9200;">-</span> solver.phase[I])<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> G(i,j<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">0.5</span>,solver.len ,solver.width) <span style="color: #bb9200;">*</span> (solver.phase[I<span style="color: #bb9200;">+</span>dy] <span style="color: #bb9200;">-</span> solver.phase[I])<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> W(solver.phase[I])
        <span style="color: #8959a8;">end</span>
   <span style="color: #8959a8;">return</span> energy
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc4e2d8a" class="outline-3">
<h3 id="orgc4e2d8a"><span class="section-number-3">3.2.</span> Massbalance</h3>
<div class="outline-text-3" id="text-3-2">
<p>
we calculate mass balance as:
</p>
\begin{align*}
bal &= \frac{\sum_{i,j \in \Omega} \phi_{ij}}{|\{(i,j) \in \Omega\}|}
\end{align*}
<p>
such that \( b = 1 \) means there is only phase one \( \phi \equiv 1 \) and \( b = -1 \) only phase -1 \( \phi \equiv -1 \)
</p>
</div>
</div>
<div id="outline-container-orgb603608" class="outline-3">
<h3 id="orgb603608"><span class="section-number-3">3.3.</span> Tests</h3>
</div>
</div>
<div id="outline-container-orgf82f796" class="outline-2">
<h2 id="orgf82f796"><span class="section-number-2">4.</span> Relaxed Problem</h2>
<div class="outline-text-2" id="text-4">
<p>
In effort to decrease the order of complexity, we propose the following relaxation to the classical Cahn Hillard Equation:
</p>
\begin{equation}
\label{org4e1e541}
\begin{aligned}
\partial_t \phi^\alpha  &= \Delta \mu \\
\mu &= \varepsilon ^2 \alpha(c^\alpha - \phi^\alpha) + W'(\phi)
\end{aligned}
\end{equation}
<p>
this in turn requires solving an additional PDE each time-step to calculate \(c\).
 \( c \) is the solution of the following elliptical PDE:
</p>
\begin{align*}
- \Delta c^\alpha  + \alpha c^a &= \alpha \phi ^\alpha
\end{align*}
<p>
As ansatz for the numerical solver we propose
</p>
\begin{equation}
\label{orgf2c0d48}
\begin{aligned}
\frac{\phi_{ij}^{n+1,\alpha} - \phi_{ij}^{n,\alpha}}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2},\alpha} )  \\
 \mu_{ij}^{n+\frac{1}{2},\alpha} &= 2\phi_{ij}^{n+1,\alpha} - \varepsilon^2 a(c_{ij}^{n+1,\alpha} - \phi_{ij}^{n+1,\alpha})  + W'(\phi_{ij}^{n,\alpha}) - 2\phi _{ij}^{n,\alpha}
\end{aligned}
\end{equation}
<p>
this approach is inspired by \eqref{orgf2c0d48} adapted to the relaxed Cahn-Hiliard equation \eqref{org26094ca}.
</p>
</div>
<div id="outline-container-org745a3af" class="outline-3">
<h3 id="org745a3af"><span class="section-number-3">4.1.</span> relaxed operators:</h3>
<div class="outline-text-3" id="text-4-1">
<p>
we then adapt the multi-grid solver proposed earlier to the relaxed Problem by replacing the differential operators by their discrete counterparts as defined in \eqref{org0dbbf07},
and expand the m
</p>
</div>
<div id="outline-container-org2a37ed9" class="outline-4">
<h4 id="org2a37ed9"><span class="section-number-4">4.1.1.</span> L Relaxed</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
for the reformulation of the iteration in terms of Operator \(L\) then follows:
</p>
\begin{align*}
L
\begin{pmatrix}
\phi ^{n+1,\alpha} \\
\mu^{n+\frac{1}{2},\alpha}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi^{n+1,m,\alpha}_{ij}}{\Delta t} - \nabla _d \cdot (G_{ji} \nabla _d \mu^{n + \frac{1}{2},m,\alpha}_{ji}) \\
\varepsilon ^2 \alpha (c^\alpha - \phi^{n+1,m,\alpha}_{ij}) - 2\phi ^{n+1,m,\alpha}_{ij} -\mu^{n + \frac{1}{2},m,\alpha}_{ji}
\end{pmatrix}
\end{align*}

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">L</span>(solver<span style="color: #bb9200;">::relaxed_multi_solver</span>,i,j , phi , mu)
    xi = solver.phase[i, j] <span style="color: #bb9200;">/</span> solver.dt <span style="color: #bb9200;">-</span>
         (discrete_G_weigted_neigbour_sum(i, j, solver.potential, G, solver.len, solver.width)
          <span style="color: #bb9200;">-</span>
          neighbours_in_domain(i, j, G, solver.len, solver.width) <span style="color: #bb9200;">*</span> mu )<span style="color: #bb9200;">/</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
    psi = solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> solver.alpha<span style="color: #bb9200;">*</span>(solver.c[i,j] <span style="color: #bb9200;">-</span> phi) <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> solver.phase[i,j] <span style="color: #bb9200;">-</span> solver.potential[i,j]
    <span style="color: #8959a8;">return</span> [xi, psi]
<span style="color: #8959a8;">end</span>
</pre>
</div>
<p>
and its relaxed derivative
</p>
\begin{align*}
DL\begin{pmatrix}
\phi \\
\mu
\end{pmatrix} &= \begin{pmatrix}
\frac{1}{\Delta t} & \frac{1}{h^2}\Sigma_{G}  \\
- \varepsilon^2 \alpha  - 2 & 1
\end{pmatrix}
\end{align*}
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">dL</span>(solver<span style="color: #bb9200;">::relaxed_multi_solver</span> , i , j)
    <span style="color: #8959a8;">return</span> [ (<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>solver.dt) (<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">/</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">*</span>neighbours_in_domain(i,j,G,solver.len , solver.width));
             (<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">*</span>solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> solver.alpha  <span style="color: #bb9200;">-</span> <span style="color: #f5871f; font-weight: bold;">2</span>) <span style="color: #f5871f; font-weight: bold;">1</span>]
    <span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga7c5ab0" class="outline-4">
<h4 id="orga7c5ab0"><span class="section-number-4">4.1.2.</span> SMOOTH</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
and correspondingly the SMOOTH operation expands to:
</p>
\begin{align*}
SMOOTH( \phi^{n+1,m,\alpha}_{ij}, \mu^{n + \frac{1}{2},m,\alpha}_{ji}, L_h , \zeta^{n,\alpha} , \psi^{n,\alpha} )
\end{align*}

\begin{equation}
\label{org1d5f40c}
\begin{aligned}
  -\frac{\Sigma_G}{h^2}\overline{\mu}^{n + \frac{1}{2},m,\alpha}_{ji} &= \frac{\phi ^{n+1,m,\alpha}_{ij}}{\Delta t} - \zeta^{n,\alpha}_{ij} - \frac{\Sigma_G\mu_{ij}}{h^2} \\
 \varepsilon ^2 \alpha \overline{\phi} ^{n+1,m,\alpha}_{ij} + 2 \phi ^{n+1,m,\alpha}_{ij} &= \varepsilon ^2 \alpha c^{n,\alpha}_{ij}  -\mu^{n + \frac{1}{2},m,\alpha}_{ji}  - \psi_{ij}^{n,\alpha}
\end{aligned}
\end{equation}
<p>
we then solve directly for \( \overline{\mu_{ij}^{n+1,m,\alpha}} \) and \( \overline{\phi_{ij}^{n+1,m,\alpha}} \). This was not done in the original paper(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) as the there required System of linear equations was solved numerically. The relaxation simplifies it to one dimension, and enables explicit solutions:
</p>
\begin{align*}
\varepsilon^2 \alpha(\phi^\alpha) + 2\phi^\alpha &= \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G} (\frac{\phi^\alpha}{\Delta t} - \zeta^n_{ij} - \frac{1}{h^2} \Sigma_G \mu_{ij}) - \psi_{ij}
\end{align*}
<p>
\( \implies \)
</p>
\begin{align*}
\varepsilon^2\alpha (\phi^\alpha) + 2\phi^\alpha + \frac{h^2}{\Sigma_G}\frac{\phi^\alpha}{\Delta t} &= \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G} (- \zeta^n_{ij} - \frac{1}{h^2} \Sigma_G \mu_{ij}) - \psi_{ij}
\end{align*}
<p>
\( \implies \)
</p>
\begin{align*}
(\varepsilon^2 \alpha + 2 + \frac{h^2}{\Sigma_G \Delta t}) \phi^\alpha = \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G}(- \zeta^n_{ij} - \frac{\Sigma_G \mu_{ij}}{h^2} ) -\psi_{ij}
\end{align*}
<p>
solved for \( \phi_{ij}^{n+1\alpha}\) the Smoothing Operator then follows:
</p>
<div class="org-src-container">
<pre class="src src-julia" id="org98cb030"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">SMOOTH!</span>(
    solver<span style="color: #bb9200;">::relaxed_multi_solver</span>,
    iterations,
    adaptive
)
    <span style="color: #8959a8;">for</span> k <span style="color: #8959a8;">=</span> <span style="color: #f5871f; font-weight: bold;">1</span>:iterations
        old_phase = copy(solver.phase)
        <span style="color: #8959a8;">for</span> I <span style="color: #8959a8;">in</span> CartesianIndices(solver.phase)[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)


            solver.phase[I] = (solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> solver.alpha <span style="color: #bb9200;">*</span> solver.c[I] <span style="color: #bb9200;">-</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">/</span> bordernumber <span style="color: #bb9200;">*</span> ( <span style="color: #bb9200;">-</span>solver.xi[I]  <span style="color: #bb9200;">-</span> discrete_G_weigted_neigbour_sum(i,j,solver.potential , G , solver.len , solver.width) <span style="color: #bb9200;">/</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> ) <span style="color: #bb9200;">-</span> solver.psi[I]) <span style="color: #bb9200;">/</span> (solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> solver.alpha  <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">/</span> (bordernumber<span style="color: #bb9200;">*</span>solver.dt))

            solver.potential[I] = (solver.phase[I]<span style="color: #bb9200;">/</span>solver.dt <span style="color: #bb9200;">-</span> solver.xi[I] <span style="color: #bb9200;">-</span> discrete_G_weigted_neigbour_sum(i,j, solver.potential , G , solver.len , solver.width)<span style="color: #bb9200;">/</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>) <span style="color: #bb9200;">*</span> (<span style="color: #bb9200;">-</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>bordernumber)
        <span style="color: #8959a8;">end</span>

        <span style="color: #8959a8;">if</span> adaptive <span style="color: #bb9200;">&amp;&amp;</span> LinearAlgebra.norm(old_phase <span style="color: #bb9200;">-</span> solver.phase) <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">1e-10</span>
            <span style="color: #8e908c;">#</span><span style="color: #8e908c;">println("SMOOTH terminated at $(k) succesfully")</span>
            <span style="color: #8959a8;">break</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia-vterm"><span style="color: #8959a8;">using</span> Plots
<span style="color: #8959a8;">using</span> LaTeXStrings
<span style="color: #8959a8;">using</span> LinearAlgebra
include(pwd() <span style="color: #bb9200;">*</span><span style="color: #718c00;">"/utils.jl"</span>)
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">SMOOTH!</span>(
    solver<span style="color: #bb9200;">::relaxed_multi_solver</span>,
    iterations,
    adaptive
)
    <span style="color: #8959a8;">for</span> k <span style="color: #8959a8;">=</span> <span style="color: #f5871f; font-weight: bold;">1</span>:iterations
        old_phase = copy(solver.phase)
        <span style="color: #8959a8;">for</span> I <span style="color: #8959a8;">in</span> CartesianIndices(solver.phase)[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>, <span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)


            solver.phase[I] = (solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> solver.alpha <span style="color: #bb9200;">*</span> solver.c[I] <span style="color: #bb9200;">-</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">/</span> bordernumber <span style="color: #bb9200;">*</span> ( <span style="color: #bb9200;">-</span>solver.xi[I]  <span style="color: #bb9200;">-</span> discrete_G_weigted_neigbour_sum(i,j,solver.potential , G , solver.len , solver.width) <span style="color: #bb9200;">/</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> ) <span style="color: #bb9200;">-</span> solver.psi[I]) <span style="color: #bb9200;">/</span> (solver.epsilon<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">*</span> solver.alpha  <span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">/</span> (bordernumber<span style="color: #bb9200;">*</span>solver.dt))

            solver.potential[I] = (solver.phase[I]<span style="color: #bb9200;">/</span>solver.dt <span style="color: #bb9200;">-</span> solver.xi[I] <span style="color: #bb9200;">-</span> discrete_G_weigted_neigbour_sum(i,j, solver.potential , G , solver.len , solver.width)<span style="color: #bb9200;">/</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>) <span style="color: #bb9200;">*</span> (<span style="color: #bb9200;">-</span>solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span><span style="color: #bb9200;">/</span>bordernumber)
        <span style="color: #8959a8;">end</span>

        <span style="color: #8959a8;">if</span> adaptive <span style="color: #bb9200;">&amp;&amp;</span> LinearAlgebra.norm(old_phase <span style="color: #bb9200;">-</span> solver.phase) <span style="color: #bb9200;">&lt;</span> <span style="color: #f5871f; font-weight: bold;">1e-10</span>
            <span style="color: #8e908c;">#</span><span style="color: #8e908c;">println("SMOOTH terminated at $(k) succesfully")</span>
            <span style="color: #8959a8;">break</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
SIZE =<span style="color: #f5871f; font-weight: bold;">64</span>
M = testdata(SIZE, <span style="color: #f5871f; font-weight: bold;">5</span> , <span style="color: #f5871f; font-weight: bold;">8</span>, <span style="color: #f5871f; font-weight: bold;">2</span>);
phase = zeros(size(M) .<span style="color: #bb9200;">+</span> <span style="color: #f5871f; font-weight: bold;">2</span>);
phase[<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">2</span>:<span style="color: #8959a8;">end</span><span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>] = M;
mu = copy(phase);
<span style="color: #4271ae;">W_prime</span>(x) = <span style="color: #bb9200;">-</span>x <span style="color: #bb9200;">*</span> (<span style="color: #f5871f; font-weight: bold;">1</span><span style="color: #bb9200;">-</span>x<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>)
<span style="color: #8959a8;">function</span> <span style="color: #4271ae;">elyps_solver!</span>(solver<span style="color: #bb9200;">::relaxed_multi_solver</span>, n)
    <span style="color: #8959a8;">for</span> k <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n
        <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">=</span> <span style="color: #f5871f; font-weight: bold;">2</span>:(solver.len<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>)
            <span style="color: #8959a8;">for</span> j <span style="color: #8959a8;">=</span> <span style="color: #f5871f; font-weight: bold;">2</span>:(solver.width<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>)
                bordernumber = neighbours_in_domain(i, j,G, solver.len, solver.width)
                solver.c[i, j] =
                    (
                        solver.alpha <span style="color: #bb9200;">*</span> solver.phase[i, j] <span style="color: #bb9200;">+</span>
                        discrete_G_weigted_neigbour_sum(i, j, solver.c, G, solver.len, solver.width) <span style="color: #bb9200;">/</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
                    ) <span style="color: #bb9200;">/</span> (bordernumber <span style="color: #bb9200;">/</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> solver.alpha)

            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
solver = relaxed_multi_solver(
    phase ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    <span style="color: #f5871f; font-weight: bold;">8e-3</span> ,<span style="color: #f5871f; font-weight: bold;">1e-3</span> , <span style="color: #f5871f; font-weight: bold;">1e-3</span> ,
    W_prime ,
    size(M , <span style="color: #f5871f; font-weight: bold;">1</span>) , size(M , <span style="color: #f5871f; font-weight: bold;">2</span>),
    <span style="color: #f5871f; font-weight: bold;">1000001</span>
)
set_xi_and_psi!(solver)
elyps_solver!(solver , <span style="color: #f5871f; font-weight: bold;">2000</span>)
SMOOTH!(solver, <span style="color: #f5871f; font-weight: bold;">1000</span>, <span style="color: #f5871f;">true</span>);
p2 = heatmap(solver.phase, aspect_ratio=<span style="color: #f5871f;">:equal</span>, title=<span style="color: #718c00;">"with solving c"</span> , xlim=(<span style="color: #f5871f; font-weight: bold;">2</span>,SIZE) , ylim=(<span style="color: #f5871f; font-weight: bold;">2</span>,SIZE));
savefig(p2,<span style="color: #718c00;">"images/smooth_relaxed.svg"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-org0e9c04c" class="outline-4">
<h4 id="org0e9c04c"><span class="section-number-4">4.1.3.</span> Relaxed V-cycle</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
As The difference between both methods is abstracted away in the operators, the relaxed V-cycle Is Identical to its original counterpart. And therefore reused. When solving the only additional step is solving the elliptical equation
Testing:
</p>
<div class="org-src-container">
<pre class="src src-julia-vterm">
set_xi_and_psi!(solver)

pbar = ProgressBar(total = <span style="color: #f5871f; font-weight: bold;">1000</span>)

anim = <span style="color: #4d4d4c; font-weight: bold;">@animate</span> <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">100</span>
    elyps_solver!(solver , <span style="color: #f5871f; font-weight: bold;">1000</span>)
    <span style="color: #8959a8;">for</span> j <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:<span style="color: #f5871f; font-weight: bold;">10</span>
        v_cycle!(testgrd, <span style="color: #f5871f; font-weight: bold;">1</span>)
        update(pbar)
        <span style="color: #8959a8;">end</span>
    set_xi_and_psi!(testgrd[<span style="color: #f5871f; font-weight: bold;">1</span>])
    heatmap(testgrd[<span style="color: #f5871f; font-weight: bold;">1</span>].phase , clim =(<span style="color: #bb9200;">-</span><span style="color: #f5871f; font-weight: bold;">1</span>,<span style="color: #f5871f; font-weight: bold;">1</span>) , framestyle=<span style="color: #f5871f;">:none</span> )
<span style="color: #8959a8;">end</span>
gif(anim , <span style="color: #718c00;">"images/iteration_relaxed2.gif"</span> , fps = <span style="color: #f5871f; font-weight: bold;">10</span>)
</pre>
</div>


<div id="org496ae48" class="figure">
<p><img src="images/iteration_relaxed2.gif" alt="iteration_relaxed2.gif" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org7505e22" class="outline-3">
<h3 id="org7505e22"><span class="section-number-3">4.2.</span> Elliptical PDE:</h3>
<div class="outline-text-3" id="text-4-2">
<p>
on order to solve the relaxed CH Equation the following PDE as to be solved in Each additional time step:
or in terms of the characteristic function:
</p>
\begin{align*}
- \nabla \cdot  (G \nabla c^\alpha) + \alpha c^\alpha  = \alpha \phi ^\alpha
\end{align*}
<p>
Similarly to the first solver this PDE is solved with a finite difference scheme using the same discretization as before:
</p>
</div>
<div id="outline-container-orgb4da064" class="outline-4">
<h4 id="orgb4da064"><span class="section-number-4">4.2.1.</span> Discretization</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
the Discretization of the PIE expands the differential operators in the same way and proposes an equivalent scheme for solving.
</p>
\begin{align*}
- \nabla_d \cdot  (G_{ij} \nabla_d c_{ij}^\alpha) + \alpha  c_{ij}^\alpha &= \alpha \phi_{ij}^\alpha
\end{align*}
<p>
\( \implies \)
</p>
\begin{align*}
- (\frac{1}{h}(G_{i+\frac{1}{2}j} \nabla c^\alpha_{i+\frac{1}{2}j} + G_{ij+\frac{1}{2}} \nabla c^\alpha_{ij+\frac{1}{2}}) &  \\
- (G_{i-\frac{1}{2}j} \nabla c^\alpha_{i-\frac{1}{2}j} + G_{ij-\frac{1}{2}} \nabla c^\alpha_{ij-\frac{1}{2}})) + \alpha  c_{ij}^\alpha   &= \alpha  \phi_{ij}^\alpha
\end{align*}
<p>
\( \implies \)
</p>
\begin{align*}
- \frac{1}{h^2} ( G_{i+\frac{1}{2}j}(c_{i+1j}^\alpha - c_{ij}^\alpha) & \\
+G_{ij+\frac{1}{2}}(c_{ij+1}^\alpha - c_{ij}^\alpha) & \\
+G_{i-\frac{1}{2}j}(c_{i-1j}^\alpha - c_{ij}^\alpha)& \\
+G_{ij-\frac{1}{2}}(c_{ij-1}^\alpha - c_{ij}^\alpha)) + \alpha  c_{ij}^\alpha &=\alpha  \phi_{ij}^\alpha
\end{align*}


<p>
As before we abbreviate \(  \Sigma_G c^\alpha_{ij} = G_{i+\frac{1}{2}j} c^\alpha_{i+1j} +  G_{i-\frac{1}{2}j} c^\alpha_{i-1j} + G_{ij+\frac{1}{2}}  c^\alpha_{ij+1} + G_{ij-\frac{1}{2}} c^\alpha_{ij-1}  \) and \(  \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}  \). Then the discrete elliptical PDE can be stated as:
</p>
\begin{align}
\label{org4391584}
-\frac{ \Sigma_G c^\alpha_{ij}}{h^2} + \frac{\Sigma_G}{h^2} c^\alpha_{ij} + \alpha c^\alpha_{ij} &= \alpha\phi^\alpha_{ij}
\end{align}
</div>
<ol class="org-ol">
<li><a id="org3a85d91"></a><span class="done DONE">DONE</span> Proposal1 Newton Solver<br />
<div class="outline-text-5" id="text-4-2-1-1">
<p>
And then we propose a simple newton Iteration to solve  \eqref{org4391584}  for \( x = c^\alpha_{ij} \):
Let \( F, dF \) be:
</p>
\begin{align*}
F(x) &= - \frac{\Sigma_Gc^\alpha_{ij}}{h^2} + \frac{\Sigma_G}{h^2}  x + \alpha x  - \alpha \phi_{ij}^\alpha
\end{align*}
<p>
and \( dF(x) \)
</p>

\begin{align*}
dF(x) &= - \frac{\Sigma_G}{h^2}    + \alpha
\end{align*}
<p>
the implementation then is the following:
</p>

<p>
as input, we use :
</p>
</div>
</li>
<li><a id="orgc17828b"></a>Proposal2  solver<br />
<div class="outline-text-5" id="text-4-2-1-2">
<p>
solving \eqref{org4391584} for \(c_{ij}^\alpha \) then results in.
</p>
\begin{align*}
\left( \frac{\Sigma_{G}}{h^2} + \alpha \right)c_{ij}^{\alpha} = \alpha\phi^{\alpha}_{ij} + \frac{\Sigma_G c_{ij}^{\alpha}}{h^2}
\end{align*}
<p>
and can be translated to code as follows
</p>
<div class="org-src-container">
<pre class="src src-julia" id="org2993b26"><span style="color: #8959a8;">function</span> <span style="color: #4271ae;">elyps_solver!</span>(solver<span style="color: #bb9200;">::relaxed_multi_solver</span>, n)
    <span style="color: #8959a8;">for</span> k <span style="color: #8959a8;">in</span> <span style="color: #f5871f; font-weight: bold;">1</span>:n
        <span style="color: #8959a8;">for</span> i <span style="color: #8959a8;">=</span> <span style="color: #f5871f; font-weight: bold;">2</span>:(solver.len<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>)
            <span style="color: #8959a8;">for</span> j <span style="color: #8959a8;">=</span> <span style="color: #f5871f; font-weight: bold;">2</span>:(solver.width<span style="color: #bb9200;">+</span><span style="color: #f5871f; font-weight: bold;">1</span>)
                bordernumber = neighbours_in_domain(i, j,G, solver.len, solver.width)
                solver.c[i, j] =
                    (
                        solver.alpha <span style="color: #bb9200;">*</span> solver.phase[i, j] <span style="color: #bb9200;">+</span>
                        discrete_G_weigted_neigbour_sum(i, j, solver.c, G, solver.len, solver.width) <span style="color: #bb9200;">/</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span>
                    ) <span style="color: #bb9200;">/</span> (bordernumber <span style="color: #bb9200;">/</span> solver.h<span style="color: #bb9200;">^</span><span style="color: #f5871f; font-weight: bold;">2</span> <span style="color: #bb9200;">+</span> solver.alpha)

            <span style="color: #8959a8;">end</span>
        <span style="color: #8959a8;">end</span>
    <span style="color: #8959a8;">end</span>
<span style="color: #8959a8;">end</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org0d3776f" class="outline-2">
<h2 id="org0d3776f"><span class="section-number-2">5.</span> References</h2>
<div class="outline-text-2" id="text-5">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Shin, Jaemin, Darae Jeong, and Junseok Kim. 2011. “A Conservative Numerical Method for the Cahn–Hilliard Equation in Complex Domains.” <i>Journal of Computational Physics</i> 230 (19): 7441–55. <a href="https://doi.org/https://doi.org/10.1016/j.jcp.2011.06.009">https://doi.org/https://doi.org/10.1016/j.jcp.2011.06.009</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>Wu, Hao. 2022. “A Review on the Cahnhilliard Equation: Classical Results and Recent Advances in Dynamic Boundary Conditions.” <i>Electronic Research Archive</i> 30 (8): 2788–2832. <a href="https://doi.org/10.3934/era.2022143">https://doi.org/10.3934/era.2022143</a>.</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jonathan Ulmer</p>
<p class="date">Created: 2024-03-14 Thu 18:46</p>
</div>
</body>
</html>
