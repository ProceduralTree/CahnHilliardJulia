<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-12 Tue 20:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bachelor Thesis</title>
<meta name="author" content="Jonathan Ulmer" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  pre.src-C\+\+:before { content: 'C++'; }
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Bachelor Thesis</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org914b6ba">1. Cahn Hillard Equation Overview</a></li>
<li><a href="#org8297123">2. Baseline Multigrid solver:</a></li>
<li><a href="#org8984637">3. Numerical Evaluation</a></li>
<li><a href="#orgd9e31bf">4. Relaxed Problem</a></li>
<li><a href="#orgaf13637">5. References</a></li>
</ul>
</div>
</div>
<div id="outline-container-org914b6ba" class="outline-2">
<h2 id="org914b6ba"><span class="section-number-2">1.</span> Cahn Hillard Equation Overview</h2>
<div class="outline-text-2" id="text-1">
<p>
Partial Differential Equation (PDE) solving the state of a two Phase Fluid(<a href="#citeproc_bib_item_2">Wu 2022</a>). The form of the Cahn Hillard Equation used for the remainder of this thesis is:
where \( \phi\) is the so-called phase field. Demarking the different states of the fluids through an Interval \(I=[-1,1] \) and where \(\partial I = \{-1,1\} \) represents full state of one fluid. \(\varepsilon > 0 \) is a positive constant
</p>
\begin{align}
\label{org793c8b3}
\phi _t(x,t) &= \Delta \mu \\
\mu &= - \varepsilon^2 \Delta \phi   + W'(\phi)
\end{align}

<p>
, and \(\mu\) is the chemical potential(<a href="#citeproc_bib_item_2">Wu 2022</a>). While the Cahn-Hillard equation exist in a more general form taking the fluid&rsquo;s mobility \(M(\Phi) \) into account, we will assume \(M(\Phi) = 1 \), simplifying the CH-Equations used in (<a href="#citeproc_bib_item_2">Wu 2022</a>) (<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) to what is stated above.
</p>


<p>
The Advantages of the Cahn Hillard Approach as compared to traditional fluid dynamics solvers are for example: &ldquo;explicit tracking of the interface&rdquo; (<a href="#citeproc_bib_item_2">Wu 2022</a>), as well as &ldquo;evolution of complex geometries and topological changes [&#x2026;] in a natural way&rdquo; (<a href="#citeproc_bib_item_2">Wu 2022</a>)
In practice it enables linear interpolation between different formulas on different phases
</p>
</div>
<div id="outline-container-orgb9b7b9f" class="outline-3">
<h3 id="orgb9b7b9f"><span class="section-number-3">1.1.</span> Derivation from paper</h3>
<div class="outline-text-3" id="text-1-1">
</div>
<div id="outline-container-org58e8019" class="outline-4">
<h4 id="org58e8019"><span class="section-number-4">1.1.1.</span> Free energy</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
The Cahn Hillard Equations can be motivated Using a <b>Ginzburg Landau</b> type free energy equation:
</p>
\begin{align*}
\label{org278616c}
E^{\text{bulk}} = \int_{\Omega} \frac{\varepsilon^2}{2} |\nabla \phi |^2 + W(\phi) \, dx
\end{align*}
<p>
where \(W(\phi) \) denotes the (Helmholtz) free energy density of mixing.&ldquo;&rdquo; (<a href="#citeproc_bib_item_2">Wu 2022</a>) and we approximate it in further calculations as \(W(\phi) = \frac{(1-\phi ^2)^2}{4}\) like in (<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>)
</p>

<p>
The chemical potential then follows as derivative of Energy in respect to time.
</p>
\begin{align*}
 \mu &= \frac{\delta E_{bulk}(\phi)}{\delta \phi} = -\varepsilon^2 \Delta \phi + W'(\phi)
\end{align*}
</div>
</div>
<div id="outline-container-org4d0910b" class="outline-4">
<h4 id="org4d0910b"><span class="section-number-4">1.1.2.</span> <span class="todo TODO">TODO</span> Derivation by mass balance</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
We motivate the Cahn Hillard equation as follows:
consider
</p>
\begin{equation}
\label{org007c7ae}
    \partial_t \phi + \nabla J = 0
\end{equation}
<p>
where <b>J</b> is mass flux. \eqref{org007c7ae} then states that the change in mass balances the change of the phase field.
Using the no-flux boundary conditions:
</p>
\begin{align}
J \cdot n &= 0 & \partial\Omega &\times (0,T)\\
\partial_n\phi &= 0 & \partial\Omega &\times (0,T)
\end{align}
<p>
conservation of mass follows see(<a href="#citeproc_bib_item_2">Wu 2022</a>).
</p>

<p>
Using:
</p>
\begin{align}
J &= - \nabla \mu
\end{align}
<p>
which conceptionally sets mass flux to equalize the potential energy gradient, leads to the formulation of the CH equations as stated above. Additionally, the boundary conditions evaluate to:
</p>
\begin{align*}
 - \nabla \mu &= 0 \\
\partial_n \phi = 0
\end{align*}
<p>
i.e. no flow leaves and potential on the border doesn&rsquo;t change.
Then for \(\phi \) then follows:
</p>
\begin{align*}
\frac{d}{dt}E^{bulk}(\phi(t)) &= \int_{\Omega} ( \varepsilon^2 \nabla \phi \cdot \nabla \partial_t \phi + W'(\phi) \partial_t \phi) \ d x \\
&= - \int_{ \Omega } |\nabla \mu|^2 \ d x, & \forall t \in (0,T)
\end{align*}
<p>
hence the Free Energy is decreasing in time.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8297123" class="outline-2">
<h2 id="org8297123"><span class="section-number-2">2.</span> Baseline Multigrid solver:</h2>
<div class="outline-text-2" id="text-2">
<p>
As baseline for further experiments we use a two grid method based on finite differences by(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>).
</p>
</div>
<div id="outline-container-orgbf69217" class="outline-3">
<h3 id="orgbf69217"><span class="section-number-3">2.1.</span> Discretization:</h3>
<div class="outline-text-3" id="text-2-1">
<p>
it discretizes the phasefield and potential energy \( \phi, \mu \) into a grid wise functions \(\phi_{ij}, \mu_{ij} \) and defines the partial derivatives \( D_xf_{ij}, \ D_yf_{ij} \) using the differential quotients:
</p>
\begin{align}
D_xf_{i+\frac{1}{2} j} &= \frac{f_{i+1j} - f_{ij}}{h} & D_yf_{ij+\frac{1}{2}} &= \frac{f_{ij+1} - f_{ij}}{h}
\end{align}
<p>
for \( \nabla f, \Delta f \) then follows:
</p>
\begin{align*}
\label{org0636f83}
\nabla_d f_{ij} &= (D_x f_{i+1j} , \ D_y f_{ij+1}) \\
 \Delta_d f_{ij} &= \frac{D_x f_{i+\frac{1}{2}j} -  D_x f_{i-\frac{1}{2}j} + D_y f_{ij+\frac{1}{2}} - D_y f_{ij-\frac{1}{2}}}{h} = \nabla_d \cdot  \nabla_d f_{ij}
\end{align*}
<p>
the authors(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) further adapt the discretized phase field by the characteristic function of the domain \( \Omega\):
</p>
\begin{align*}
G(x,y) &=
\begin{cases}
1 & (x,y) \in  \Omega \\
0 & (x,y) \not\in  \Omega
\end{cases}
\end{align*}

<p>
To simplify notation we use the following abbreviations:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Math</td>
<td class="org-left">Code</td>
</tr>

<tr>
<td class="org-left">\(  \Sigma_G f_{ij} = G_{i+\frac{1}{2}j} f^{n + \frac{1}{2},m}_{i+1j} +  G_{i-\frac{1}{2}j} f^{n + \frac{1}{2},m}_{i-1j} + G_{ij+\frac{1}{2}}  f^{n + \frac{1}{2},m}_{ij+1} + G_{ij-\frac{1}{2}} f^{n + \frac{1}{2},m}_{ij-1}  \)</td>
<td class="org-left"><code>discrete_weigted_neigbour_sum(i,j,...)</code></td>
</tr>

<tr>
<td class="org-left">\(  \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}  \)</td>
<td class="org-left"><code>neighbours_in_domain(i,j,G)</code></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">neighbours_in_domain</span>(i, j, G, len, width)
    (
        G(i <span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">0.5</span>, j, len, width)
        <span style="color: #f0c674;">+</span> G(i <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">0.5</span>, j, len, width)
        <span style="color: #f0c674;">+</span> G(i, j <span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">0.5</span>, len, width)
        <span style="color: #f0c674;">+</span> G(i, j <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">0.5</span>, len, width)
    )

<span style="color: #b294bb;">end</span>
<span style="color: #b294bb;">function</span> <span style="color: #81a2be;">discrete_G_weigted_neigbour_sum</span>(i, j, arr, G, len, width)
    (
        G(i <span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">0.5</span>, j, len, width) <span style="color: #f0c674;">*</span> arr[i<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">1</span>, j]
        <span style="color: #f0c674;">+</span> G(i <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">0.5</span>, j, len, width) <span style="color: #f0c674;">*</span> arr[i<span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>, j]
        <span style="color: #f0c674;">+</span> G(i, j <span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">0.5</span>, len, width) <span style="color: #f0c674;">*</span> arr[i, j<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">1</span>]
        <span style="color: #f0c674;">+</span> G(i, j <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">0.5</span>, len, width) <span style="color: #f0c674;">*</span> arr[i, j<span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>]
    )
<span style="color: #b294bb;">end</span>
</pre>
</div>

<p>
We can then write for the solver necessary modified Laplacian \( \nabla_d (G \nabla_df_{ij}) \) as
</p>
\begin{align*}
\nabla_{d}(G \nabla_df_{ij}) &= \frac{\Sigma_Gf_{ij} - \Sigma_G\cdot f_{ij}}{h^2}
\end{align*}

<p>
To account for no flux boundary conditions and arbitrary shaped domains.
The authors (<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) then define the discrete CH Equation adapted for Domain, as:
</p>

\begin{align}
\label{org721eaad}
\frac{\phi_{ij}^{n+1} - \phi_{ij}^n}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2}} )  \\
 \mu_{ij}^{n+\frac{1}{2}} &= 2\phi_{ij}^{n+1} - \varepsilon^2  \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1} ) + W'(\phi_{ij}^n) - 2\phi _{ij}^n
\end{align}
<p>
and derive from these implicit equations a numerical scheme.
</p>
</div>
</div>
<div id="outline-container-orge95991f" class="outline-3">
<h3 id="orge95991f"><span class="section-number-3">2.2.</span> adaptations to the simplified problem</h3>
<div class="outline-text-3" id="text-2-2">
<p>
even tough this work uses rectangular domains, we simplify the adaptation of the algorithm by the domain indicator function, as well as 0 padding, in order to correctly include the boundary conditions of the CH equation.
Therefore, the internal representation of the adapted algorithm considers phase field and potential field \( \phi , \mu \) as 2D arrays of shape \( (N_x + 2 , N_y + 2) \) in order to accommodate padding. Where N<sub>x</sub> and N<sub>y</sub> are the number of steps in x-/y-Direction respectively.
Hence, we define the discrete domain function as:
</p>
\begin{align*}
G_{ij} &=
\begin{cases}
1 & (i,j) \in  [1,N_x+1] \times  [1,N_y+1] \\
0 & \text{else}
\end{cases}
\end{align*}

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b5bd68;">"""</span>
<span style="color: #b5bd68;">Boundry indicator function</span>

<span style="color: #b5bd68;">Returns</span>
<span style="color: #b5bd68;">---------------</span>
<span style="color: #b5bd68;">1 if index i,j is in bounds(without padding) and 0 else</span>
<span style="color: #b5bd68;">"""</span>
</pre>
</div>
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">G</span>(i, j, len, width)
    <span style="color: #b294bb;">if</span> <span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">&lt;=</span> i <span style="color: #f0c674;">&lt;=</span> len <span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">1</span> <span style="color: #f0c674;">&amp;&amp;</span> <span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">&lt;=</span> j <span style="color: #f0c674;">&lt;=</span> width <span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">1</span>
        <span style="color: #b294bb;">return</span> <span style="color: #de935f; font-weight: bold;">1.0</span>
    <span style="color: #b294bb;">else</span>
        <span style="color: #b294bb;">return</span> <span style="color: #de935f; font-weight: bold;">0.0</span>
    <span style="color: #b294bb;">end</span>
<span style="color: #b294bb;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org3f17583" class="outline-3">
<h3 id="org3f17583"><span class="section-number-3">2.3.</span> PDE as Operator</h3>
<div class="outline-text-3" id="text-2-3">
<p>
and derive the iteration operator \( L(\phi^{n+1} , \mu^{n+\frac{1}{2}}) = (\zeta^n ,\psi^n) \)as in(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>)
</p>
\begin{align*}
L
\begin{pmatrix}
\phi^{n+1}_{ij} \\
\mu^{n+\frac{1}{2}}_{ij}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi^{n+1}_{ij}}{\Delta t} - \nabla _d \cdot  ( G_{ij} \nabla _d \mu^{n+\frac{1}{2}}_{ij} ) \\
\varepsilon^2 \nabla _d \cdot  (G \nabla_d \phi_{ij}^{n+1}) - 2\phi_{ij}^{n+1} + \mu_{ij}^{n+\frac{1}{2}}
\end{pmatrix}
\end{align*}
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">L</span>(solver<span style="color: #f0c674;">::multi_solver</span>,i,j , phi , mu)
    xi = solver.phase[i, j] <span style="color: #f0c674;">/</span> solver.dt <span style="color: #f0c674;">-</span>
         (discrete_G_weigted_neigbour_sum(i, j, solver.potential, G, solver.len, solver.width)
          <span style="color: #f0c674;">-</span>
          neighbours_in_domain(i, j, G, solver.len, solver.width) <span style="color: #f0c674;">*</span> mu )<span style="color: #f0c674;">/</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>
    psi = solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span><span style="color: #f0c674;">/</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span>
          (discrete_G_weigted_neigbour_sum(i, j, solver.phase, G, solver.len, solver.width)
           <span style="color: #f0c674;">-</span>
           neighbours_in_domain(i, j, G, solver.len, solver.width) <span style="color: #f0c674;">*</span> phi) <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> phi <span style="color: #f0c674;">+</span> mu
    <span style="color: #b294bb;">return</span> [xi, psi]
<span style="color: #b294bb;">end</span>
</pre>
</div>
<p>
this operator follows from \eqref{org721eaad} by separating implicit and explicit terms \( L \) and   \( (\zeta^n_{ij} , \psi^n_{ij})^T \) respectively.
</p>
\begin{align*}
\begin{pmatrix}
\zeta^n
 \\
\psi^n
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi_{ij}^{n}}{\Delta t}\\
W'(\phi_{ij}^n) - 2\phi_{ij}^n
\end{pmatrix}
\end{align*}
<p>
Due to being explicit, we know everything needed to calculate \( (\zeta^n_{ij} , \psi^n_{ij})^T \). We compute those values  once for every time step, and store them.
</p>
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">set_xi_and_psi!</span>(solver<span style="color: #f0c674;">::T</span>) <span style="color: #b294bb;">where</span> T <span style="color: #f0c674;">&lt;:</span> <span style="color: #f0c674;">Union</span>{multi_solver , relaxed_multi_solver}
    <span style="color: #81a2be;">xi_init</span>(x) = x <span style="color: #f0c674;">/</span> solver.dt
    <span style="color: #81a2be;">psi_init</span>(x) = solver.W_prime(x) <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> x
    solver.xi[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>, <span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>] = xi_init.(solver.phase[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>,<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>])
    solver.psi[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>, <span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>] = psi_init.(solver.phase[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>,<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>])
    <span style="color: #b294bb;">return</span> <span style="color: #de935f;">nothing</span>
<span style="color: #b294bb;">end</span>

</pre>
</div>

<p>
Furthermore, as it enables a Newton iteration we derive its derivative in respect to the current grid point \( (\phi^{n+1}_{ij} , \mu^{n+\frac{1}{2}}_{ij})^{T} \):
</p>

\begin{align*}
DL\begin{pmatrix}
\phi \\
\mu
\end{pmatrix} &= \begin{pmatrix}
\frac{1}{\Delta t} & \frac{1}{h^2}\Sigma_{G}  \\
-\frac{\varepsilon^2}{h^2}\Sigma_{G} - 2 & 1
\end{pmatrix}
\end{align*}
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">dL</span>(solver<span style="color: #f0c674;">::multi_solver</span> , i , j)
    <span style="color: #b294bb;">return</span> [ (<span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">/</span>solver.dt) (<span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">/</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span><span style="color: #f0c674;">*</span>neighbours_in_domain(i,j,G,solver.len , solver.width));
             (<span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">*</span>solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span><span style="color: #f0c674;">/</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> neighbours_in_domain(i,j,G,solver.len , solver.width) <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">2</span>) <span style="color: #de935f; font-weight: bold;">1</span>]
    <span style="color: #b294bb;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8b3f7ff" class="outline-3">
<h3 id="org8b3f7ff"><span class="section-number-3">2.4.</span> v-cycle</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The numerical method proposed in (<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) of a V-cycle multigrid method derived from previously stated operators. Specificly we use a two grid implementation consisting of
</p>
<ol class="org-ol">
<li>A Gaus-Seidel Relaxation for Smoothing</li>
<li>restriction and prolongation methods between grids \(  h \leftrightarrow H  \)</li>
<li>a Newton Iteration to solve \( L(x,y)_H = L(\bar{x} , \bar{y}) + (d_h , r_h) \)</li>
</ol>

<p>
The v-cycle of a two grid method  using pre and post smoothing is then stated by:
</p>
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">v_cycle!</span>(grid<span style="color: #f0c674;">::Array</span>{T}, level) <span style="color: #b294bb;">where</span> T <span style="color: #f0c674;">&lt;:</span> <span style="color: #f0c674;">Union</span>{multi_solver , relaxed_multi_solver}

    solver = grid[level]
    <span style="color: #5a5b5a;">#</span><span style="color: #5a5b5a;">pre SMOOTHing:</span>
    SMOOTH!(solver, <span style="color: #de935f; font-weight: bold;">400</span>, <span style="color: #de935f;">true</span>)

    d = zeros(size(solver.phase))
    r = zeros(size(solver.phase))

    <span style="color: #5a5b5a;"># </span><span style="color: #5a5b5a;">calculate error between L and expected values</span>
    <span style="color: #b294bb;">for</span> I <span style="color: #b294bb;">in</span> CartesianIndices(solver.phase)[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>, <span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>]
        d[I], r[I] = [solver.xi[I], solver.psi[I]] .<span style="color: #f0c674;">-</span> L(solver, I.I..., solver.phase[I], solver.potential[I])
    <span style="color: #b294bb;">end</span>

    restrict_solver!(grid[level], grid[level<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">1</span>])
    solver = grid[level<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">1</span>]
    solution = deepcopy(solver)

    d_large = restrict(d, G)
    r_large = restrict(r, G)


    u_large = zeros(size(d_large))
    v_large = zeros(size(d_large))

    <span style="color: #5a5b5a;">#</span><span style="color: #5a5b5a;">Newton Iteration for solving smallgrid</span>
    <span style="color: #b294bb;">for</span> i <span style="color: #b294bb;">=</span> <span style="color: #de935f; font-weight: bold;">1</span>:<span style="color: #de935f; font-weight: bold;">300</span>
        <span style="color: #b294bb;">for</span> I <span style="color: #b294bb;">in</span> CartesianIndices(solver.phase)[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>, <span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>]

            diffrence = L(solution, I.I..., solution.phase[I], solution.potential[I]) .<span style="color: #f0c674;">-</span> [d_large[I], r_large[I]] .<span style="color: #f0c674;">-</span> L(solver, I.I..., solver.phase[I], solver.potential[I])
            <span style="color: #5a5b5a;">#</span><span style="color: #5a5b5a;">diffrence = collect(L(solution, I.I...)) .- collect(L(solver, I.I...))</span>
            <span style="color: #5a5b5a;">#</span><span style="color: #5a5b5a;">diffrence = [d_large[I] , r_large[I]]</span>

            <span style="color: #b294bb;">local</span> ret = dL(solution, I.I...) <span style="color: #f0c674;">\</span> diffrence

            u_large[I] = ret[<span style="color: #de935f; font-weight: bold;">1</span>]
            v_large[I] = ret[<span style="color: #de935f; font-weight: bold;">2</span>]
        <span style="color: #b294bb;">end</span>
        solution.phase .<span style="color: #f0c674;">-=</span> u_large
        solution.potential .<span style="color: #f0c674;">-=</span> v_large
    <span style="color: #b294bb;">end</span>

    u_large = solver.phase .<span style="color: #f0c674;">-</span> solution.phase
    v_large = solver.potential .<span style="color: #f0c674;">-</span> solution.potential

    solver = grid[level]

    solver.phase .<span style="color: #f0c674;">+=</span> prolong(u_large , G)
    solver.potential .<span style="color: #f0c674;">+=</span> prolong(v_large, G)
    SMOOTH!(solver, <span style="color: #de935f; font-weight: bold;">800</span>, <span style="color: #de935f;">true</span>)
<span style="color: #b294bb;">end</span>
</pre>
</div>
<p>
So let&rsquo;s take a closer look at the internals, namely the phase field after pre-SMOOTHing \( \bar{\phi} \), the phase residuals of \( \left[ L(\bar{\phi_{ij}}, \bar{\mu_{ij}}) - (\zeta_{ij} , \psi_{ij}) \right]_{ij \in \Omega} \) and the result of the Newton iteration on coarsest level.
</p>

<div id="orge26250d" class="figure">
<p><img src="images/v_cycle.svg" alt="v_cycle.svg" class="org-svg" />
</p>
</div>

<p>
and a few iterations of the V-cycle exhibit the following behavior:
</p>

<div class="org-src-container">
<pre class="src src-julia-vterm">
set_xi_and_psi!(solver)

pbar = ProgressBar(total = <span style="color: #de935f; font-weight: bold;">1000</span>)

anim = <span style="color: #c5c8c6; font-weight: bold;">@animate</span> <span style="color: #b294bb;">for</span> i <span style="color: #b294bb;">in</span> <span style="color: #de935f; font-weight: bold;">1</span>:<span style="color: #de935f; font-weight: bold;">100</span>
    <span style="color: #b294bb;">for</span> j <span style="color: #b294bb;">in</span> <span style="color: #de935f; font-weight: bold;">1</span>:<span style="color: #de935f; font-weight: bold;">10</span>
        v_cycle!(testgrd, <span style="color: #de935f; font-weight: bold;">1</span>)
        update(pbar)
        <span style="color: #b294bb;">end</span>
    set_xi_and_psi!(testgrd[<span style="color: #de935f; font-weight: bold;">1</span>])
    heatmap(testgrd[<span style="color: #de935f; font-weight: bold;">1</span>].phase , clim =(<span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>,<span style="color: #de935f; font-weight: bold;">1</span>) , framestyle=<span style="color: #de935f;">:none</span> )
<span style="color: #b294bb;">end</span>
gif(anim , <span style="color: #b5bd68;">"images/iteration.gif"</span> , fps = <span style="color: #de935f; font-weight: bold;">10</span>)
</pre>
</div>


<div id="orga91ec33" class="figure">
<p><img src="images/iteration.gif" alt="iteration.gif" />
</p>
</div>
</div>
</div>
<div id="outline-container-orgba8a8e7" class="outline-3">
<h3 id="orgba8a8e7"><span class="section-number-3">2.5.</span> SMOOTH Operator</h3>
<div class="outline-text-3" id="text-2-5">
<p>
(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>)derive Gaus-Seidel Smoothing by:
</p>
\begin{align*}
L
\begin{pmatrix}
\phi^{n+1}_{ij} \\
\mu^{n+\frac{1}{2}}_{ij}
\end{pmatrix}
&=
\begin{pmatrix}
\zeta^n_{ij} \\
\psi^n_{ij}
\end{pmatrix}
\end{align*}
<p>
solved for \( \phi , \mu \).
 SMOOTH consists of point-wise Gauß Seidel Relaxation, by solving <i>L</i> for \( \overline{\phi} ,\overline{\mu} \) with the initial guess for \( \zeta^n , \psi^n \).
</p>
\begin{align}
SMOOTH
\end{align}
<p>
and we implement it as
</p>
<div class="org-src-container">
<pre class="src src-julia" id="orgbc53faa"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">SMOOTH!</span>(
    solver<span style="color: #f0c674;">::multi_solver</span>,
    iterations,
    adaptive
)
    <span style="color: #b294bb;">for</span> k <span style="color: #b294bb;">=</span> <span style="color: #de935f; font-weight: bold;">1</span>:iterations
        old_phase = copy(solver.phase)
        <span style="color: #b294bb;">for</span> I <span style="color: #b294bb;">in</span> CartesianIndices(solver.phase)[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>, <span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)

            coefmatrix = dL(solver, i,j )

            b =
                [
                    (
                        solver.xi[i, j]
                        <span style="color: #f0c674;">+</span>
                        discrete_G_weigted_neigbour_sum(
                            i, j, solver.potential, G, solver.len, solver.width
                        )
                        <span style="color: #f0c674;">/</span>
                        solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>
                    ),
                    (
                        solver.psi[i, j]
                        <span style="color: #f0c674;">-</span>
                        (solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">/</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>)
                        <span style="color: #f0c674;">*</span>
                        discrete_G_weigted_neigbour_sum(
                            i, j, solver.phase, G, solver.len, solver.width
                        )
                    )
                ]

            res = coefmatrix <span style="color: #f0c674;">\</span> b
            solver.phase[i, j] = res[<span style="color: #de935f; font-weight: bold;">1</span>]
            solver.potential[i, j] = res[<span style="color: #de935f; font-weight: bold;">2</span>]

        <span style="color: #b294bb;">end</span>

        <span style="color: #b294bb;">if</span> adaptive <span style="color: #f0c674;">&amp;&amp;</span> LinearAlgebra.norm(old_phase <span style="color: #f0c674;">-</span> solver.phase) <span style="color: #f0c674;">&lt;</span> <span style="color: #de935f; font-weight: bold;">1e-8</span>
            <span style="color: #5a5b5a;">#</span><span style="color: #5a5b5a;">println("SMOOTH terminated at $(k) succesfully")</span>
            <span style="color: #b294bb;">break</span>
        <span style="color: #b294bb;">end</span>
    <span style="color: #b294bb;">end</span>
<span style="color: #b294bb;">end</span>
</pre>
</div>


<div id="org270a9b2" class="figure">
<p><img src="images/smooth.svg" alt="smooth.svg" class="org-svg" />
</p>
</div>
</div>
</div>
<div id="outline-container-org8d14d9c" class="outline-3">
<h3 id="org8d14d9c"><span class="section-number-3">2.6.</span> Test Data:</h3>
<div class="outline-text-3" id="text-2-6">
<p>
For testing and later training we use a multitude o different phase fields. Notably an assortment of randomly placed circles, squares, and arbitrary generated values
</p>

<table id="org0ff5359" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Size</th>
<th scope="col" class="org-right">blobs</th>
<th scope="col" class="org-right">blobsize</th>
<th scope="col" class="org-right">norm</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">64</td>
<td class="org-right">10</td>
<td class="org-right">10</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">64</td>
<td class="org-right">10</td>
<td class="org-right">10</td>
<td class="org-right">100</td>
</tr>

<tr>
<td class="org-right">512</td>
<td class="org-right">20</td>
<td class="org-right">50</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-julia" id="orgd6e78a3"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">testdata</span>(gridsize , blobs , radius ,norm)
rngpoints = rand(<span style="color: #de935f; font-weight: bold;">1</span>:gridsize, <span style="color: #de935f; font-weight: bold;">2</span>, blobs)
M = zeros(gridsize,gridsize) .<span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">1</span>
<span style="color: #b294bb;">for</span> p <span style="color: #b294bb;">in</span> axes(rngpoints , <span style="color: #de935f; font-weight: bold;">2</span>)
    point = rngpoints[:, p]
    <span style="color: #b294bb;">for</span> I <span style="color: #b294bb;">in</span> CartesianIndices(M)
        <span style="color: #b294bb;">if</span> (LinearAlgebra.norm(point .<span style="color: #f0c674;">-</span> I.I  , norm) <span style="color: #f0c674;">&lt;</span> radius)
            M[I] = <span style="color: #de935f; font-weight: bold;">1</span>
        <span style="color: #b294bb;">end</span>
    <span style="color: #b294bb;">end</span>
<span style="color: #b294bb;">end</span>
M
<span style="color: #b294bb;">end</span>
</pre>
</div>


<div id="org5074efd" class="figure">
<p><img src="testdata.svg" alt="testdata.svg" class="org-svg" />
</p>
<p><span class="figure-number">Figure 1: </span>Examples of different phasefields used as initial condition later on</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8984637" class="outline-2">
<h2 id="org8984637"><span class="section-number-2">3.</span> Numerical Evaluation</h2>
<div class="outline-text-2" id="text-3">
<p>
The analytical Chan-Hilliard equation exhibits mass conservation \eqref{org007c7ae} and a decrease in Energy \( E_{bulk} \) \eqref{org278616c}. Therefore, we use discrete variants of those concepts as necessary conditions for a &ldquo;good&rdquo; solution. Furthermore, since \( E_{bulk} \) is closely correlated with potential Energy \( \mu \), we evaluate this difference as quality of convergence.
</p>
</div>
<div id="outline-container-org7f00e51" class="outline-3">
<h3 id="org7f00e51"><span class="section-number-3">3.1.</span> Energy Evaluations</h3>
<div class="outline-text-3" id="text-3-1">
<p>
As discrete energy measure we use
</p>
\begin{align*}
E^{\text{bulk}} &= \sum_{i,j \in \Omega} \frac{\varepsilon^2}{2} |G\nabla \phi_{ij} |^2 + W\left(\phi_{ij}\right) \, dx \\
&= \sum_{i,j \in \Omega} \frac{\varepsilon^2}{2} G_{i+\frac{1}{2}j}D_x\phi_{i+\frac{1}{2}j} ^2 + G_{ij+\frac{1}{2}}D_y\phi_{ij+\frac{1}{2}}^2  + W\left(\phi_{ij}\right) \, dx \\
\end{align*}
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">bulk_energy</span>(solver<span style="color: #f0c674;">::T</span>) <span style="color: #b294bb;">where</span> T <span style="color: #f0c674;">&lt;:</span> <span style="color: #f0c674;">Union</span>{multi_solver , relaxed_multi_solver}
    energy = <span style="color: #de935f; font-weight: bold;">0</span>
    dx = CartesianIndex(<span style="color: #de935f; font-weight: bold;">1</span>,<span style="color: #de935f; font-weight: bold;">0</span>)
    dy = CartesianIndex(<span style="color: #de935f; font-weight: bold;">0</span>,<span style="color: #de935f; font-weight: bold;">1</span>)
    <span style="color: #81a2be;">W</span>(x) = <span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">/</span><span style="color: #de935f; font-weight: bold;">4</span> <span style="color: #f0c674;">*</span> (<span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">-</span>x<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>)<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>
    <span style="color: #b294bb;">for</span> I <span style="color: #b294bb;">in</span> CartesianIndices(solver.phase)[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>,<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>]
        i,j = I.I
        energy <span style="color: #f0c674;">+=</span> solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">/</span> <span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> G(i<span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">0.5</span>,j ,solver.len, solver.width) <span style="color: #f0c674;">*</span> (solver.phase[I<span style="color: #f0c674;">+</span>dx] <span style="color: #f0c674;">-</span> solver.phase[I])<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">+</span> G(i,j<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">0.5</span>,solver.len ,solver.width) <span style="color: #f0c674;">*</span> (solver.phase[I<span style="color: #f0c674;">+</span>dy] <span style="color: #f0c674;">-</span> solver.phase[I])<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">+</span> W(solver.phase[I])
        <span style="color: #b294bb;">end</span>
   <span style="color: #b294bb;">return</span> energy
<span style="color: #b294bb;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org648d9ff" class="outline-3">
<h3 id="org648d9ff"><span class="section-number-3">3.2.</span> Massbalance</h3>
<div class="outline-text-3" id="text-3-2">
<p>
we calculate mass balance as:
</p>
\begin{align*}
bal &= \frac{\sum_{i,j \in \Omega} \phi_{ij}}{|\{(i,j) \in \Omega\}|}
\end{align*}
<p>
such that \( b = 1 \) means there is only phase one \( \phi \equiv 1 \) and \( b = -1 \) only phase -1 \( \phi \equiv -1 \)
</p>
</div>
</div>
<div id="outline-container-orgd945418" class="outline-3">
<h3 id="orgd945418"><span class="section-number-3">3.3.</span> Tests</h3>
</div>
</div>
<div id="outline-container-orgd9e31bf" class="outline-2">
<h2 id="orgd9e31bf"><span class="section-number-2">4.</span> Relaxed Problem</h2>
<div class="outline-text-2" id="text-4">
<p>
In effort to decrease the order of complexity, we propose the following relaxation to the classical Cahn Hillard Equation:
</p>
\begin{align}
\label{orgf123ba3}
\partial_t \phi^\alpha  &= \Delta \mu \\
\mu &= \varepsilon ^2 \alpha(c^\alpha - \phi^\alpha) + W'(\phi)
\end{align}
<p>
this in turn requires solving an additional PDE each time-step to calculate \(c\).
 \( c \) is the solution of the following elliptical PDE:
</p>
\begin{align*}
- \Delta c^\alpha  + \alpha c^a &= \alpha \phi ^\alpha
\end{align*}
<p>
As ansatz for the numerical solver we propose
</p>
\begin{align}
\label{org4e2aad8}
\frac{\phi_{ij}^{n+1,\alpha} - \phi_{ij}^{n,\alpha}}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2},\alpha} )  \\
 \mu_{ij}^{n+\frac{1}{2},\alpha} &= 2\phi_{ij}^{n+1,\alpha} - \varepsilon^2 a(c_{ij}^{n+1,\alpha} - \phi_{ij}^{n+1,\alpha})  + W'(\phi_{ij}^{n,\alpha}) - 2\phi _{ij}^{n,\alpha}
\end{align}
<p>
this approach is inspired by \eqref{org4e2aad8} adapted to the relaxed Cahn-Hiliard equation \eqref{orgf123ba3}.
</p>
</div>
<div id="outline-container-org02bb484" class="outline-3">
<h3 id="org02bb484"><span class="section-number-3">4.1.</span> relaxed operators:</h3>
<div class="outline-text-3" id="text-4-1">
<p>
we then adapt the multi-grid solver proposed earlier to the relaxed Problem by replacing the differential operators by their discrete counterparts as defined in \eqref{org0636f83},
and expand them
</p>
</div>
<div id="outline-container-org115b352" class="outline-4">
<h4 id="org115b352"><span class="section-number-4">4.1.1.</span> L Relaxed</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
for the reformulation of the iteration in terms of Operator \(L\) then follows:
</p>
\begin{align*}
L
\begin{pmatrix}
\phi ^{n+1,\alpha} \\
\mu^{n+\frac{1}{2},\alpha}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi^{n+1,m,\alpha}_{ij}}{\Delta t} - \nabla _d \cdot (G_{ji} \nabla _d \mu^{n + \frac{1}{2},m,\alpha}_{ji}) \\
\varepsilon ^2 \alpha (c^\alpha - \phi^{n+1,m,\alpha}_{ij}) - 2\phi ^{n+1,m,\alpha}_{ij} -\mu^{n + \frac{1}{2},m,\alpha}_{ji}
\end{pmatrix}
\end{align*}

<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">L</span>(solver<span style="color: #f0c674;">::relaxed_multi_solver</span>,i,j , phi , mu)
    xi = solver.phase[i, j] <span style="color: #f0c674;">/</span> solver.dt <span style="color: #f0c674;">-</span>
         (discrete_G_weigted_neigbour_sum(i, j, solver.potential, G, solver.len, solver.width)
          <span style="color: #f0c674;">-</span>
          neighbours_in_domain(i, j, G, solver.len, solver.width) <span style="color: #f0c674;">*</span> mu )<span style="color: #f0c674;">/</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>
    psi = solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> solver.alpha<span style="color: #f0c674;">*</span>(solver.c[i,j] <span style="color: #f0c674;">-</span> phi) <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> solver.phase[i,j] <span style="color: #f0c674;">-</span> solver.potential[i,j]
    <span style="color: #b294bb;">return</span> [xi, psi]
<span style="color: #b294bb;">end</span>
</pre>
</div>
<p>
and its relaxed derivative
</p>
\begin{align*}
DL\begin{pmatrix}
\phi \\
\mu
\end{pmatrix} &= \begin{pmatrix}
\frac{1}{\Delta t} & \frac{1}{h^2}\Sigma_{G}  \\
- \varepsilon^2 \alpha  - 2 & 1
\end{pmatrix}
\end{align*}
<div class="org-src-container">
<pre class="src src-julia"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">dL</span>(solver<span style="color: #f0c674;">::relaxed_multi_solver</span> , i , j)
    <span style="color: #b294bb;">return</span> [ (<span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">/</span>solver.dt) (<span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">/</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span><span style="color: #f0c674;">*</span>neighbours_in_domain(i,j,G,solver.len , solver.width));
             (<span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">*</span>solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> solver.alpha  <span style="color: #f0c674;">-</span> <span style="color: #de935f; font-weight: bold;">2</span>) <span style="color: #de935f; font-weight: bold;">1</span>]
    <span style="color: #b294bb;">end</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd5d47f8" class="outline-4">
<h4 id="orgd5d47f8"><span class="section-number-4">4.1.2.</span> SMOOTH</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
and correspondingly the SMOOTH operation expands to:
</p>
\begin{align*}
SMOOTH( \phi^{n+1,m,\alpha}_{ij}, \mu^{n + \frac{1}{2},m,\alpha}_{ji}, L_h , \zeta^{n,\alpha} , \psi^{n,\alpha} )
\end{align*}

\begin{align}
\label{orgdd91d06}
  -\frac{\Sigma_G}{h^2}\overline{\mu}^{n + \frac{1}{2},m,\alpha}_{ji} &= \frac{\phi ^{n+1,m,\alpha}_{ij}}{\Delta t} - \zeta^{n,\alpha}_{ij} - \frac{\Sigma_G\mu_{ij}}{h^2} \\
 \varepsilon ^2 \alpha \overline{\phi} ^{n+1,m,\alpha}_{ij} + 2 \phi ^{n+1,m,\alpha}_{ij} &= \varepsilon ^2 \alpha c^{n,\alpha}_{ij}  -\mu^{n + \frac{1}{2},m,\alpha}_{ji}  - \psi_{ij}^{n,\alpha}
\end{align}
</div>
<ol class="org-ol">
<li><a id="org30e20c0"></a>Proposal2<br />
<div class="outline-text-5" id="text-4-1-2-1">
<p>
solve for \( \overline{\mu_{ij}^{n+1,m,\alpha}} \) and \( \overline{\phi_{ij}^{n+1,m,\alpha}} \). This was not done in the original paper(<a href="#citeproc_bib_item_1">Shin, Jeong, and Kim 2011</a>) as the there required System of linear equations was solved numerically. The relaxation simplifies it to one dimension, and enables explicit solutions:
</p>
\begin{align*}
\varepsilon^2 \alpha(\phi^\alpha) + 2\phi^\alpha &= \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G} (\frac{\phi^\alpha}{\Delta t} - \zeta^n_{ij} - \frac{1}{h^2} \Sigma_G \mu_{ij}) - \psi_{ij}
\end{align*}
<p>
\( \implies \)
</p>
\begin{align*}
\varepsilon^2\alpha (\phi^\alpha) + 2\phi^\alpha + \frac{h^2}{\Sigma_G}\frac{\phi^\alpha}{\Delta t} &= \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G} (- \zeta^n_{ij} - \frac{1}{h^2} \Sigma_G \mu_{ij}) - \psi_{ij}
\end{align*}
<p>
\( \implies \)
</p>
\begin{align*}
(\varepsilon^2 \alpha + 2 + \frac{h^2}{\Sigma_G \Delta t}) \phi^\alpha = \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G}(- \zeta^n_{ij} - \frac{\Sigma_G \mu_{ij}}{h^2} ) -\psi_{ij}
\end{align*}
<p>
solved for \( \phi_{ij}^{n+1\alpha}\) the Smoothing Operator then follows:
</p>
<div class="org-src-container">
<pre class="src src-julia" id="org90d12a0"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">SMOOTH!</span>(
    solver<span style="color: #f0c674;">::relaxed_multi_solver</span>,
    iterations,
    adaptive
)
    <span style="color: #b294bb;">for</span> k <span style="color: #b294bb;">=</span> <span style="color: #de935f; font-weight: bold;">1</span>:iterations
        old_phase = copy(solver.phase)
        <span style="color: #b294bb;">for</span> I <span style="color: #b294bb;">in</span> CartesianIndices(solver.phase)[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>, <span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)


            solver.phase[I] = (solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> solver.alpha <span style="color: #f0c674;">*</span> solver.c[I] <span style="color: #f0c674;">-</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">/</span> bordernumber <span style="color: #f0c674;">*</span> ( <span style="color: #f0c674;">-</span>solver.xi[I]  <span style="color: #f0c674;">-</span> discrete_G_weigted_neigbour_sum(i,j,solver.potential , G , solver.len , solver.width) <span style="color: #f0c674;">/</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> ) <span style="color: #f0c674;">-</span> solver.psi[I]) <span style="color: #f0c674;">/</span> (solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> solver.alpha  <span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">+</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">/</span> (bordernumber<span style="color: #f0c674;">*</span>solver.dt))

            solver.potential[I] = (solver.phase[I]<span style="color: #f0c674;">/</span>solver.dt <span style="color: #f0c674;">-</span> solver.xi[I] <span style="color: #f0c674;">-</span> discrete_G_weigted_neigbour_sum(i,j, solver.potential , G , solver.len , solver.width)<span style="color: #f0c674;">/</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>) <span style="color: #f0c674;">*</span> (<span style="color: #f0c674;">-</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span><span style="color: #f0c674;">/</span>bordernumber)
        <span style="color: #b294bb;">end</span>

        <span style="color: #b294bb;">if</span> adaptive <span style="color: #f0c674;">&amp;&amp;</span> LinearAlgebra.norm(old_phase <span style="color: #f0c674;">-</span> solver.phase) <span style="color: #f0c674;">&lt;</span> <span style="color: #de935f; font-weight: bold;">1e-10</span>
            <span style="color: #5a5b5a;">#</span><span style="color: #5a5b5a;">println("SMOOTH terminated at $(k) succesfully")</span>
            <span style="color: #b294bb;">break</span>
        <span style="color: #b294bb;">end</span>
    <span style="color: #b294bb;">end</span>
<span style="color: #b294bb;">end</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-julia-vterm"><span style="color: #b294bb;">using</span> Plots
<span style="color: #b294bb;">using</span> LaTeXStrings
<span style="color: #b294bb;">using</span> LinearAlgebra
include(pwd() <span style="color: #f0c674;">*</span><span style="color: #b5bd68;">"/utils.jl"</span>)
<span style="color: #b294bb;">function</span> <span style="color: #81a2be;">SMOOTH!</span>(
    solver<span style="color: #f0c674;">::relaxed_multi_solver</span>,
    iterations,
    adaptive
)
    <span style="color: #b294bb;">for</span> k <span style="color: #b294bb;">=</span> <span style="color: #de935f; font-weight: bold;">1</span>:iterations
        old_phase = copy(solver.phase)
        <span style="color: #b294bb;">for</span> I <span style="color: #b294bb;">in</span> CartesianIndices(solver.phase)[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>, <span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)


            solver.phase[I] = (solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> solver.alpha <span style="color: #f0c674;">*</span> solver.c[I] <span style="color: #f0c674;">-</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">/</span> bordernumber <span style="color: #f0c674;">*</span> ( <span style="color: #f0c674;">-</span>solver.xi[I]  <span style="color: #f0c674;">-</span> discrete_G_weigted_neigbour_sum(i,j,solver.potential , G , solver.len , solver.width) <span style="color: #f0c674;">/</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> ) <span style="color: #f0c674;">-</span> solver.psi[I]) <span style="color: #f0c674;">/</span> (solver.epsilon<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">*</span> solver.alpha  <span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">+</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">/</span> (bordernumber<span style="color: #f0c674;">*</span>solver.dt))

            solver.potential[I] = (solver.phase[I]<span style="color: #f0c674;">/</span>solver.dt <span style="color: #f0c674;">-</span> solver.xi[I] <span style="color: #f0c674;">-</span> discrete_G_weigted_neigbour_sum(i,j, solver.potential , G , solver.len , solver.width)<span style="color: #f0c674;">/</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>) <span style="color: #f0c674;">*</span> (<span style="color: #f0c674;">-</span>solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span><span style="color: #f0c674;">/</span>bordernumber)
        <span style="color: #b294bb;">end</span>

        <span style="color: #b294bb;">if</span> adaptive <span style="color: #f0c674;">&amp;&amp;</span> LinearAlgebra.norm(old_phase <span style="color: #f0c674;">-</span> solver.phase) <span style="color: #f0c674;">&lt;</span> <span style="color: #de935f; font-weight: bold;">1e-10</span>
            <span style="color: #5a5b5a;">#</span><span style="color: #5a5b5a;">println("SMOOTH terminated at $(k) succesfully")</span>
            <span style="color: #b294bb;">break</span>
        <span style="color: #b294bb;">end</span>
    <span style="color: #b294bb;">end</span>
<span style="color: #b294bb;">end</span>
SIZE =<span style="color: #de935f; font-weight: bold;">64</span>
M = testdata(SIZE, <span style="color: #de935f; font-weight: bold;">5</span> , <span style="color: #de935f; font-weight: bold;">8</span>, <span style="color: #de935f; font-weight: bold;">2</span>);
phase = zeros(size(M) .<span style="color: #f0c674;">+</span> <span style="color: #de935f; font-weight: bold;">2</span>);
phase[<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>,<span style="color: #de935f; font-weight: bold;">2</span>:<span style="color: #b294bb;">end</span><span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>] = M;
mu = copy(phase);
<span style="color: #81a2be;">W_prime</span>(x) = <span style="color: #f0c674;">-</span>x <span style="color: #f0c674;">*</span> (<span style="color: #de935f; font-weight: bold;">1</span><span style="color: #f0c674;">-</span>x<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>)
<span style="color: #b294bb;">function</span> <span style="color: #81a2be;">elyps_solver!</span>(solver<span style="color: #f0c674;">::relaxed_multi_solver</span>, n)
    <span style="color: #b294bb;">for</span> k <span style="color: #b294bb;">in</span> <span style="color: #de935f; font-weight: bold;">1</span>:n
        <span style="color: #b294bb;">for</span> i <span style="color: #b294bb;">=</span> <span style="color: #de935f; font-weight: bold;">2</span>:(solver.len<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">1</span>)
            <span style="color: #b294bb;">for</span> j <span style="color: #b294bb;">=</span> <span style="color: #de935f; font-weight: bold;">2</span>:(solver.width<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">1</span>)
                bordernumber = neighbours_in_domain(i, j,G, solver.len, solver.width)
                solver.c[i, j] =
                    (
                        solver.alpha <span style="color: #f0c674;">*</span> solver.phase[i, j] <span style="color: #f0c674;">+</span>
                        discrete_G_weigted_neigbour_sum(i, j, solver.c, G, solver.len, solver.width) <span style="color: #f0c674;">/</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>
                    ) <span style="color: #f0c674;">/</span> (bordernumber <span style="color: #f0c674;">/</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">+</span> solver.alpha)

            <span style="color: #b294bb;">end</span>
        <span style="color: #b294bb;">end</span>
    <span style="color: #b294bb;">end</span>
<span style="color: #b294bb;">end</span>
solver = relaxed_multi_solver(
    phase ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    <span style="color: #de935f; font-weight: bold;">8e-3</span> ,<span style="color: #de935f; font-weight: bold;">1e-3</span> , <span style="color: #de935f; font-weight: bold;">1e-3</span> ,
    W_prime ,
    size(M , <span style="color: #de935f; font-weight: bold;">1</span>) , size(M , <span style="color: #de935f; font-weight: bold;">2</span>),
    <span style="color: #de935f; font-weight: bold;">1000001</span>
)
set_xi_and_psi!(solver)
elyps_solver!(solver , <span style="color: #de935f; font-weight: bold;">2000</span>)
SMOOTH!(solver, <span style="color: #de935f; font-weight: bold;">1000</span>, <span style="color: #de935f;">true</span>);
p2 = heatmap(solver.phase, aspect_ratio=<span style="color: #de935f;">:equal</span>, title=<span style="color: #b5bd68;">"with solving c"</span> , xlim=(<span style="color: #de935f; font-weight: bold;">2</span>,SIZE) , ylim=(<span style="color: #de935f; font-weight: bold;">2</span>,SIZE));
savefig(p2,<span style="color: #b5bd68;">"images/smooth_relaxed.svg"</span>)
</pre>
</div>
</div>
</li>
</ol>
</div>
<div id="outline-container-org59e9df0" class="outline-4">
<h4 id="org59e9df0"><span class="section-number-4">4.1.3.</span> Relaxed V-cycle</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
As The difference between both methods is abstracted away in the operators, the relaxed V-cycle Is Identical to its original counterpart. And therefore reused.
Testing:
</p>
<div class="org-src-container">
<pre class="src src-julia-vterm">
set_xi_and_psi!(solver)

pbar = ProgressBar(total = <span style="color: #de935f; font-weight: bold;">1000</span>)

anim = <span style="color: #c5c8c6; font-weight: bold;">@animate</span> <span style="color: #b294bb;">for</span> i <span style="color: #b294bb;">in</span> <span style="color: #de935f; font-weight: bold;">1</span>:<span style="color: #de935f; font-weight: bold;">100</span>
    elyps_solver!(solver , <span style="color: #de935f; font-weight: bold;">1000</span>)
    <span style="color: #b294bb;">for</span> j <span style="color: #b294bb;">in</span> <span style="color: #de935f; font-weight: bold;">1</span>:<span style="color: #de935f; font-weight: bold;">10</span>
        v_cycle!(testgrd, <span style="color: #de935f; font-weight: bold;">1</span>)
        update(pbar)
        <span style="color: #b294bb;">end</span>
    set_xi_and_psi!(testgrd[<span style="color: #de935f; font-weight: bold;">1</span>])
    heatmap(testgrd[<span style="color: #de935f; font-weight: bold;">1</span>].phase , clim =(<span style="color: #f0c674;">-</span><span style="color: #de935f; font-weight: bold;">1</span>,<span style="color: #de935f; font-weight: bold;">1</span>) , framestyle=<span style="color: #de935f;">:none</span> )
<span style="color: #b294bb;">end</span>
gif(anim , <span style="color: #b5bd68;">"images/iteration_relaxed2.gif"</span> , fps = <span style="color: #de935f; font-weight: bold;">10</span>)
</pre>
</div>


<div id="orgee16d64" class="figure">
<p><img src="images/iteration_relaxed2.gif" alt="iteration_relaxed2.gif" />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga6bdccd" class="outline-3">
<h3 id="orga6bdccd"><span class="section-number-3">4.2.</span> Elliptical PDE:</h3>
<div class="outline-text-3" id="text-4-2">
<p>
on order to solve the relaxed CH Equation the following PDE as to be solved in Each additional time step:
or in terms of the characteristic function:
</p>
\begin{align*}
- \nabla \cdot  (G \nabla c^\alpha) + \alpha c^\alpha  = \alpha \phi ^\alpha
\end{align*}
<p>
Similarly to the first solver this PDE is solved with a finite difference scheme using the same discretization as before:
</p>
</div>
<div id="outline-container-org85ad083" class="outline-4">
<h4 id="org85ad083"><span class="section-number-4">4.2.1.</span> Discretization</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
the Discretization of the PIE expands the differential operators in the same way and proposes an equivalent scheme for solving.
</p>
\begin{align*}
- \nabla_d \cdot  (G_{ij} \nabla_d c_{ij}^\alpha) + \alpha  c_{ij}^\alpha &= \alpha \phi_{ij}^\alpha
\end{align*}
<p>
\( \implies \)
</p>
\begin{align*}
- (\frac{1}{h}(G_{i+\frac{1}{2}j} \nabla c^\alpha_{i+\frac{1}{2}j} + G_{ij+\frac{1}{2}} \nabla c^\alpha_{ij+\frac{1}{2}}) &  \\
- (G_{i-\frac{1}{2}j} \nabla c^\alpha_{i-\frac{1}{2}j} + G_{ij-\frac{1}{2}} \nabla c^\alpha_{ij-\frac{1}{2}})) + \alpha  c_{ij}^\alpha   &= \alpha  \phi_{ij}^\alpha
\end{align*}
<p>
\( \implies \)
</p>
\begin{align*}
- \frac{1}{h^2} ( G_{i+\frac{1}{2}j}(c_{i+1j}^\alpha - c_{ij}^\alpha) & \\
+G_{ij+\frac{1}{2}}(c_{ij+1}^\alpha - c_{ij}^\alpha) & \\
+G_{i-\frac{1}{2}j}(c_{i-1j}^\alpha - c_{ij}^\alpha)& \\
+G_{ij-\frac{1}{2}}(c_{ij-1}^\alpha - c_{ij}^\alpha)) + \alpha  c_{ij}^\alpha &=\alpha  \phi_{ij}^\alpha
\end{align*}


<p>
As before we abbreviate \(  \Sigma_G c^\alpha_{ij} = G_{i+\frac{1}{2}j} c^\alpha_{i+1j} +  G_{i-\frac{1}{2}j} c^\alpha_{i-1j} + G_{ij+\frac{1}{2}}  c^\alpha_{ij+1} + G_{ij-\frac{1}{2}} c^\alpha_{ij-1}  \) and \(  \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}  \). Then the discrete elliptical PDE can be stated as:
</p>
\begin{align}
\label{org3ca23f2}
-\frac{ \Sigma_G c^\alpha_{ij}}{h^2} + \frac{\Sigma_G}{h^2} c^\alpha_{ij} + \alpha c^\alpha_{ij} &= \alpha\phi^\alpha_{ij}
\end{align}
</div>
<ol class="org-ol">
<li><a id="org5e87a8f"></a><span class="done DONE">DONE</span> Proposal1 Newton Solver<br />
<div class="outline-text-5" id="text-4-2-1-1">
<p>
And then we propose a simple newton Iteration to solve  \eqref{org3ca23f2}  for \( x = c^\alpha_{ij} \):
Let \( F, dF \) be:
</p>
\begin{align*}
F(x) &= - \frac{\Sigma_Gc^\alpha_{ij}}{h^2} + \frac{\Sigma_G}{h^2}  x + \alpha x  - \alpha \phi_{ij}^\alpha
\end{align*}
<p>
and \( dF(x) \)
</p>

\begin{align*}
dF(x) &= - \frac{\Sigma_G}{h^2}    + \alpha
\end{align*}
<p>
the implementation then is the following:
</p>

<p>
as input, we use :
</p>
</div>
</li>
<li><a id="org7980e78"></a>Proposal2  solver<br />
<div class="outline-text-5" id="text-4-2-1-2">
<p>
solving \eqref{org3ca23f2} for \(c_{ij}^\alpha \) then results in.
</p>
\begin{align*}
\left( \frac{\Sigma_{G}}{h^2} + \alpha \right)c_{ij}^{\alpha} = \alpha\phi^{\alpha}_{ij} + \frac{\Sigma_G c_{ij}^{\alpha}}{h^2}
\end{align*}
<p>
and can be translated to code as follows
</p>
<div class="org-src-container">
<pre class="src src-julia" id="orgba6f3fe"><span style="color: #b294bb;">function</span> <span style="color: #81a2be;">elyps_solver!</span>(solver<span style="color: #f0c674;">::relaxed_multi_solver</span>, n)
    <span style="color: #b294bb;">for</span> k <span style="color: #b294bb;">in</span> <span style="color: #de935f; font-weight: bold;">1</span>:n
        <span style="color: #b294bb;">for</span> i <span style="color: #b294bb;">=</span> <span style="color: #de935f; font-weight: bold;">2</span>:(solver.len<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">1</span>)
            <span style="color: #b294bb;">for</span> j <span style="color: #b294bb;">=</span> <span style="color: #de935f; font-weight: bold;">2</span>:(solver.width<span style="color: #f0c674;">+</span><span style="color: #de935f; font-weight: bold;">1</span>)
                bordernumber = neighbours_in_domain(i, j,G, solver.len, solver.width)
                solver.c[i, j] =
                    (
                        solver.alpha <span style="color: #f0c674;">*</span> solver.phase[i, j] <span style="color: #f0c674;">+</span>
                        discrete_G_weigted_neigbour_sum(i, j, solver.c, G, solver.len, solver.width) <span style="color: #f0c674;">/</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span>
                    ) <span style="color: #f0c674;">/</span> (bordernumber <span style="color: #f0c674;">/</span> solver.h<span style="color: #f0c674;">^</span><span style="color: #de935f; font-weight: bold;">2</span> <span style="color: #f0c674;">+</span> solver.alpha)

            <span style="color: #b294bb;">end</span>
        <span style="color: #b294bb;">end</span>
    <span style="color: #b294bb;">end</span>
<span style="color: #b294bb;">end</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgaf13637" class="outline-2">
<h2 id="orgaf13637"><span class="section-number-2">5.</span> References</h2>
<div class="outline-text-2" id="text-5">
<style>.csl-entry{text-indent: -1.5em; margin-left: 1.5em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>Shin, Jaemin, Darae Jeong, and Junseok Kim. 2011. “A Conservative Numerical Method for the Cahn–Hilliard Equation in Complex Domains.” <i>Journal of Computational Physics</i> 230 (19): 7441–55. <a href="https://doi.org/https://doi.org/10.1016/j.jcp.2011.06.009">https://doi.org/https://doi.org/10.1016/j.jcp.2011.06.009</a>.</div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>Wu, Hao. 2022. “A Review on the Cahnhilliard Equation: Classical Results and Recent Advances in Dynamic Boundary Conditions.” <i>Electronic Research Archive</i> 30 (8): 2788–2832. <a href="https://doi.org/10.3934/era.2022143">https://doi.org/10.3934/era.2022143</a>.</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jonathan Ulmer</p>
<p class="date">Created: 2024-03-12 Tue 20:53</p>
</div>
</body>
</html>
