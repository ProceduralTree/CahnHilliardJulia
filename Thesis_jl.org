#+title: Bachelor Thesis
#+BIBLIOGRAPHY: ~/org/resources/bibliography/refs.bib
#+property: header-args:python :noweb strip-export
#+options:  toc:1
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
* Utility functions :noexport:
#+name: imports
#+begin_src julia :session jl :results silent :exports none
using Plots
using LinearAlgebra
#+end_src

#+begin_src julia :tangle multisolver.jl :eval never
include(pwd() * "/" * "utils.jl")
#+end_src

#+begin_src  julia :tangle utils.jl :eval never
###############################################################################
#                  Common Utility Functions For Multi Solvers                 #
###############################################################################

"""
restricts an array on the small grid to an array in the large grid asserts size arr=2^n + 2 and returns ret=2^(n-1) + 2

Returns
---------------------------
large grid array + padding
"""
function restrict(arr, G)
    shape = (size(arr) .- 2) .÷ 2
    ret = zeros(shape .+ 2)
    for I in CartesianIndices(ret)[2:end-1, 2:end-1]
        i, j = I.I
        g = [
            G(2 * i - 1, 2 * j - 1, (size(arr) .- 2)...),
            G(2 * i - 1, 2 * j, (size(arr) .- 2)...),
            G(2 * i, 2 * j - 1, (size(arr) .- 2)...),
            G(2 * i, 2 * j, (size(arr) .- 2)...)
        ]
        if sum(g) == 0
            ret[I] = 0
        else
            ret[I] = (
                1 / sum(g)
                ,*
                dot(g,
                    [
                        arr[2*i-1, 2*j-1],
                        arr[2*i-1, 2*j],
                        arr[2*i, 2*j-1],
                        arr[2*i, 2*j]
                    ]
                )
            )
        end
    end
    return ret
end

"""
    prolong(arr , G)

interpolates int a smaller grid by a factor of 2

"""
function prolong(arr, G)
    inner_shape = (size(arr) .- 2) .* 2
    ret = zeros(inner_shape .+ 2)
    ONE = oneunit(CartesianIndices(arr)[1])
    for I in CartesianIndices(arr)[2:end-1, 2:end-1]
        Ind = 2 * (I - ONE) + ONE
        for J in (Ind-ONE):Ind
            ret[J] = G(J.I..., inner_shape...) * arr[I]
        end
    end
    return ret
end

struct multi_solver
    phase::Matrix{Float64}
    potential::Matrix{Float64}
    xi::Matrix{Float64}
    psi::Matrix{Float64}
    epsilon::Float64
    h::Float64
    dt::Float64
    W_prime::Function
    len::Int
    width::Int

end
struct relaxed_multi_solver
    phase::Matrix{Float64}
    potential::Matrix{Float64}
    xi::Matrix{Float64}
    psi::Matrix{Float64}
    c::Matrix{Float64}
    epsilon::Float64
    h::Float64
    dt::Float64
    W_prime::Function
    len::Int
    width::Int
    alpha::Float64

end

function testgrid(M, len)
    grid = Array{multi_solver}(undef, len)
    phase = zeros(size(M) .+ 2)
    phase[2:end-1, 2:end-1] = M
    W_prime(x) = -x * (1 - x^2)
    h0 = 3e-3


    for i = 1:len
        grid[i] = multi_solver(zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            8e-3, h0 * 2^i, 1e-3,
            W_prime,
            size(M, 1) ÷ i, size(M, 2) ÷ i)

    end
    copyto!(grid[1].phase, phase)
    return grid

end

function relaxed_testgrid(M, len)
    grid = Array{relaxed_multi_solver}(undef, len)
    phase = zeros(size(M) .+ 2)
    phase[2:end-1, 2:end-1] = M
    W_prime(x) = -x * (1 - x^2)
    h0 = 3e-3

    for i = 1:len
        grid[i] = relaxed_multi_solver(zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            zeros(size(M) .÷ i .+ 2),
            8e-3, h0 * 2^i, 1e-3,
            W_prime,
            size(M, 1) ÷ i, size(M, 2) ÷ i,
            1000001)

    end
    copyto!(grid[1].phase, phase)
    return grid
end

"""
    restrict!(smallgrid_solver::multi_solver , largegrid_solver::multi_solver)::multi_solver

------------
Requires
----------
smallgrid solver and largegid solvers to be multiple of 2 from each other bar padding eg. (66x66)->(34x34)

------------
Returns
------------
    nothing. mutatest largegid in place to represent the smallgrid

"""
function restrict_solver!(smallgrid_solver::T, largegrid_solver::T) where {T<:Union{multi_solver,relaxed_multi_solver}}
    copy!(largegrid_solver.phase, restrict(smallgrid_solver.phase, G))
    copy!(largegrid_solver.potential, restrict(smallgrid_solver.potential, G))
    return nothing
end
#+end_src

#+name: setup-grid
#+begin_src julia :eval never
include(pwd() * "/" * "utils.jl")
include(pwd() * "/" * "multisolver.jl")
using Plots
using LaTeXStrings
using LinearAlgebra
using Printf
M = testdata(256, 10, 50 , 2)

testgrd = testgrid(M, 2)
solver = testgrd[1]
#+end_src

#+name: setup-relaxed-grid
#+begin_src julia :eval never
include(pwd() * "/" * "utils.jl")
include(pwd() * "/" * "multisolver.jl")
include(pwd() * "/" * "multi_relaxed.jl")
include(pwd() * "/" * "elypssolver.jl")
using Plots
using LinearAlgebra
using ProgressBars
M = testdata(32, 5, 8 , 2)

testgrd = relaxed_testgrid(M, 2)
println("Hi")
solver = testgrd[1]
#+end_src
* Cahn Hillard Equation Overview
Partial Differential Equation (PDE) solving the state of a two Phase Fluid[cite:@Wu_2022]. The form of the Cahn Hillard Equation used for the remainder of this thesis is:
where \( \phi\) is the so-called phase field. Demarking the different states of the fluids through an Interval \(I=[-1,1] \) and where \(\partial I = \{-1,1\} \) represents full state of one fluid. \(\varepsilon > 0 \) is a positive constant
#+name: eq:CH
\begin{align}
\phi _t(x,t) &= \Delta \mu \\
\mu &= - \varepsilon^2 \Delta \phi   + W'(\phi)
\end{align}
# describing the width of the phase transition
, and \(\mu\) is the chemical potential[cite:@Wu_2022]. While the Cahn-Hillard equation exist in a more general form taking the fluid's mobility \(M(\Phi) \) into account, we will assume \(M(\Phi) = 1 \), simplifying the CH-Equations used in [cite:@Wu_2022] [cite:@SHIN20117441] to what is stated above.


The Advantages of the Cahn Hillard Approach as compared to traditional fluid dynamics solvers are for example: "explicit tracking of the interface"[cite:@Wu_2022], as well as "evolution of complex geometries and topological changes [...] in a natural way"[cite:@Wu_2022]
In practice it enables linear interpolation between different formulas on different phases
** Derivation from paper
*** Free energy
The Cahn Hillard Equations can be motivated Using a *Ginzburg Landau* type free energy equation:
#+name: eq:energy
\begin{align*}
E^{\text{bulk}} = \int_{\Omega} \frac{\varepsilon^2}{2} |\nabla \phi |^2 + W(\phi) \, dx
\end{align*}
where \(W(\phi) \) denotes the (Helmholtz) free energy density of mixing.""[cite:@Wu_2022] and we approximate it in further calculations as \(W(\phi) = \frac{(1-\phi ^2)^2}{4}\) like in [cite:@SHIN20117441]

The chemical potential then follows as derivative of Energy in respect to time.
\begin{align*}
 \mu &= \frac{\delta E_{bulk}(\phi)}{\delta \phi} = -\varepsilon^2 \Delta \phi + W'(\phi)
\end{align*}

*** TODO Derivation by mass balance
We motivate the Cahn Hillard equation as follows:
consider
#+name: eq:massbal
\begin{equation}
    \partial_t \phi + \nabla J = 0
\end{equation}
where *J* is mass flux. [[eq:massbal]] then states that the change in mass balances the change of the phase field.
Using the no-flux boundary conditions:
\begin{align}
J \cdot n &= 0 & \partial\Omega &\times (0,T)\\
\partial_n\phi &= 0 & \partial\Omega &\times (0,T)
\end{align}
conservation of mass follows see[cite:@Wu_2022].

Using:
\begin{align}
J &= - \nabla \mu
\end{align}
which conceptionally sets mass flux to equalize the potential energy gradient, leads to the formulation of the CH equations as stated above. Additionally, the boundary conditions evaluate to:
\begin{align*}
 - \nabla \mu &= 0 \\
\partial_n \phi = 0
\end{align*}
i.e. no flow leaves and potential on the border doesn't change.
Then for \(\phi \) then follows:
\begin{align*}
\frac{d}{dt}E^{bulk}(\phi(t)) &= \int_{\Omega} ( \varepsilon^2 \nabla \phi \cdot \nabla \partial_t \phi + W'(\phi) \partial_t \phi) \ d x \\
&= - \int_{ \Omega } |\nabla \mu|^2 \ d x, & \forall t \in (0,T)
\end{align*}
hence the Free Energy is decreasing in time.
* Baseline Multigrid solver:
As baseline for further experiments we use a two grid method based on finite differences by[cite:@SHIN20117441].
** Discretization:
it discretizes the phasefield and potential energy \( \phi, \mu \) into a grid wise functions \(\phi_{ij}, \mu_{ij} \) and defines the partial derivatives \( D_xf_{ij}, \ D_yf_{ij} \) using the differential quotients:
\begin{align}
D_xf_{i+\frac{1}{2} j} &= \frac{f_{i+1j} - f_{ij}}{h} & D_yf_{ij+\frac{1}{2}} &= \frac{f_{ij+1} - f_{ij}}{h}
\end{align}
for \( \nabla f, \Delta f \) then follows:
#+name: eq:discretization
\begin{align*}
\nabla_d f_{ij} &= (D_x f_{i+1j} , \ D_y f_{ij+1}) \\
 \Delta_d f_{ij} &= \frac{D_x f_{i+\frac{1}{2}j} -  D_x f_{i-\frac{1}{2}j} + D_y f_{ij+\frac{1}{2}} - D_y f_{ij-\frac{1}{2}}}{h} = \nabla_d \cdot  \nabla_d f_{ij}
\end{align*}
the authors[cite:@SHIN20117441] further adapt the discretized phase field by the characteristic function of the domain \( \Omega\):
\begin{align*}
G(x,y) &=
\begin{cases}
1 & (x,y) \in  \Omega \\
0 & (x,y) \not\in  \Omega
\end{cases}
\end{align*}

To simplify notation we use the following abbreviations:

| Math                                                                                                                                                                                                                         | Code                                   |
| \(  \Sigma_G f_{ij} = G_{i+\frac{1}{2}j} f^{n + \frac{1}{2},m}_{i+1j} +  G_{i-\frac{1}{2}j} f^{n + \frac{1}{2},m}_{i-1j} + G_{ij+\frac{1}{2}}  f^{n + \frac{1}{2},m}_{ij+1} + G_{ij-\frac{1}{2}} f^{n + \frac{1}{2},m}_{ij-1}  \) | ~discrete_weigted_neigbour_sum(i,j,...)~ |
| \(  \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}  \)                                                                                                                              | ~neighbours_in_domain(i,j,G)~            |
|                                                                                                                                                                                                                              |                                        |
#+begin_src julia :tangle utils.jl :eval never
function neighbours_in_domain(i, j, G, len, width)
    (
        G(i + 0.5, j, len, width)
        + G(i - 0.5, j, len, width)
        + G(i, j + 0.5, len, width)
        + G(i, j - 0.5, len, width)
    )

end
function discrete_G_weigted_neigbour_sum(i, j, arr, G, len, width)
    (
        G(i + 0.5, j, len, width) * arr[i+1, j]
        + G(i - 0.5, j, len, width) * arr[i-1, j]
        + G(i, j + 0.5, len, width) * arr[i, j+1]
        + G(i, j - 0.5, len, width) * arr[i, j-1]
    )
end
#+end_src

We can then write for the solver necessary modified Laplacian \( \nabla_d (G \nabla_df_{ij}) \) as
\begin{align*}
\nabla_{d}(G \nabla_df_{ij}) &= \frac{\Sigma_Gf_{ij} - \Sigma_G\cdot f_{ij}}{h^2}
\end{align*}

To account for no flux boundary conditions and arbitrary shaped domains.
The authors [cite:@SHIN20117441] then define the discrete CH Equation adapted for Domain, as:

#+name: eq:discrete-cahn-hilliard
\begin{align}
\frac{\phi_{ij}^{n+1} - \phi_{ij}^n}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2}} )  \\
 \mu_{ij}^{n+\frac{1}{2}} &= 2\phi_{ij}^{n+1} - \varepsilon^2  \nabla_d \cdot  (G_{ij} \nabla _d \phi_{ij}^{n+1} ) + W'(\phi_{ij}^n) - 2\phi _{ij}^n
\end{align}
and derive from these implicit equations a numerical scheme.
** adaptations to the simplified problem
even tough this work uses rectangular domains, we simplify the adaptation of the algorithm by the domain indicator function, as well as 0 padding, in order to correctly include the boundary conditions of the CH equation.
Therefore, the internal representation of the adapted algorithm considers phase field and potential field \( \phi , \mu \) as 2D arrays of shape \( (N_x + 2 , N_y + 2) \) in order to accommodate padding. Where N_x and N_y are the number of steps in x-/y-Direction respectively.
Hence, we define the discrete domain function as:
\begin{align*}
G_{ij} &=
\begin{cases}
1 & (i,j) \in  [1,N_x+1] \times  [1,N_y+1] \\
0 & \text{else}
\end{cases}
\end{align*}

#+begin_src julia :tangle utils.jl :eval never :export none
"""
Boundry indicator function

Returns
---------------
1 if index i,j is in bounds(without padding) and 0 else
"""
#+end_src
#+begin_src julia :tangle utils.jl :eval never
function G(i, j, len, width)
    if 2 <= i <= len + 1 && 2 <= j <= width + 1
        return 1.0
    else
        return 0.0
    end
end
#+end_src
** PDE as Operator
and derive the iteration operator \( L(\phi^{n+1} , \mu^{n+\frac{1}{2}}) = (\zeta^n ,\psi^n) \)as in[cite:@SHIN20117441]
\begin{align*}
L
\begin{pmatrix}
\phi^{n+1}_{ij} \\
\mu^{n+\frac{1}{2}}_{ij}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi^{n+1}_{ij}}{\Delta t} - \nabla _d \cdot  ( G_{ij} \nabla _d \mu^{n+\frac{1}{2}}_{ij} ) \\
\varepsilon^2 \nabla _d \cdot  (G \nabla_d \phi_{ij}^{n+1}) - 2\phi_{ij}^{n+1} + \mu_{ij}^{n+\frac{1}{2}}
\end{pmatrix}
\end{align*}
#+begin_src julia :tangle multisolver.jl :eval never
function L(solver::multi_solver,i,j , phi , mu)
    xi = solver.phase[i, j] / solver.dt -
         (discrete_G_weigted_neigbour_sum(i, j, solver.potential, G, solver.len, solver.width)
          -
          neighbours_in_domain(i, j, G, solver.len, solver.width) * mu )/solver.h^2
    psi = solver.epsilon^2/solver.h^2 *
          (discrete_G_weigted_neigbour_sum(i, j, solver.phase, G, solver.len, solver.width)
           -
           neighbours_in_domain(i, j, G, solver.len, solver.width) * phi) - 2 * phi + mu
    return [xi, psi]
end
#+end_src
this operator follows from [[eq:discrete-cahn-hilliard]] by separating implicit and explicit terms \( L \) and   \( (\zeta^n_{ij} , \psi^n_{ij})^T \) respectively.
\begin{align*}
\begin{pmatrix}
\zeta^n
 \\
\psi^n
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi_{ij}^{n}}{\Delta t}\\
W'(\phi_{ij}^n) - 2\phi_{ij}^n
\end{pmatrix}
\end{align*}
Due to being explicit, we know everything needed to calculate \( (\zeta^n_{ij} , \psi^n_{ij})^T \). We compute those values  once for every time step, and store them.
#+begin_src julia :tangle utils.jl :eval never
function set_xi_and_psi!(solver::T) where T <: Union{multi_solver , relaxed_multi_solver}
    xi_init(x) = x / solver.dt
    psi_init(x) = solver.W_prime(x) - 2 * x
    solver.xi[2:end-1, 2:end-1] = xi_init.(solver.phase[2:end-1,2:end-1])
    solver.psi[2:end-1, 2:end-1] = psi_init.(solver.phase[2:end-1,2:end-1])
    return nothing
end

#+end_src

Furthermore, as it enables a Newton iteration we derive its derivative in respect to the current grid point \( (\phi^{n+1}_{ij} , \mu^{n+\frac{1}{2}}_{ij})^{T} \):

\begin{align*}
DL\begin{pmatrix}
\phi \\
\mu
\end{pmatrix} &= \begin{pmatrix}
\frac{1}{\Delta t} & \frac{1}{h^2}\Sigma_{G}  \\
-\frac{\varepsilon^2}{h^2}\Sigma_{G} - 2 & 1
\end{pmatrix}
\end{align*}
#+begin_src julia :tangle multisolver.jl :eval never
function dL(solver::multi_solver , i , j)
    return [ (1/solver.dt) (1/solver.h^2*neighbours_in_domain(i,j,G,solver.len , solver.width));
             (-1*solver.epsilon^2/solver.h^2 * neighbours_in_domain(i,j,G,solver.len , solver.width) - 2) 1]
    end
#+end_src
** v-cycle
The numerical method proposed in [cite:@SHIN20117441] of a V-cycle multigrid method derived from previously stated operators. Specificly we use a two grid implementation consisting of
1. A Gaus-Seidel Relaxation for Smoothing
2. restriction and prolongation methods between grids \(  h \leftrightarrow H  \)
3. a Newton Iteration to solve \( L(x,y)_H = L(\bar{x} , \bar{y}) + (d_h , r_h) \)

The v-cycle of a two grid method  using pre and post smoothing is then stated by:
#+begin_src julia :tangle multisolver.jl :eval never
function v_cycle!(grid::Array{T}, level) where T <: Union{multi_solver , relaxed_multi_solver}

    solver = grid[level]
    #pre SMOOTHing:
    SMOOTH!(solver, 400, true)

    d = zeros(size(solver.phase))
    r = zeros(size(solver.phase))

    # calculate error between L and expected values
    for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]
        d[I], r[I] = [solver.xi[I], solver.psi[I]] .- L(solver, I.I..., solver.phase[I], solver.potential[I])
    end

    restrict_solver!(grid[level], grid[level+1])
    solver = grid[level+1]
    solution = deepcopy(solver)

    d_large = restrict(d, G)
    r_large = restrict(r, G)


    u_large = zeros(size(d_large))
    v_large = zeros(size(d_large))

    #Newton Iteration for solving smallgrid
    for i = 1:300
        for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]

            diffrence = L(solution, I.I..., solution.phase[I], solution.potential[I]) .- [d_large[I], r_large[I]] .- L(solver, I.I..., solver.phase[I], solver.potential[I])
            #diffrence = collect(L(solution, I.I...)) .- collect(L(solver, I.I...))
            #diffrence = [d_large[I] , r_large[I]]

            local ret = dL(solution, I.I...) \ diffrence

            u_large[I] = ret[1]
            v_large[I] = ret[2]
        end
        solution.phase .-= u_large
        solution.potential .-= v_large
    end

    u_large = solver.phase .- solution.phase
    v_large = solver.potential .- solution.potential

    solver = grid[level]

    solver.phase .+= prolong(u_large , G)
    solver.potential .+= prolong(v_large, G)
    SMOOTH!(solver, 800, true)
end
#+end_src
So let's take a closer look at the internals, namely the phase field after pre-SMOOTHing \( \bar{\phi} \), the phase residuals of \( \left[ L(\bar{\phi_{ij}}, \bar{\mu_{ij}}) - (\zeta_{ij} , \psi_{ij}) \right]_{ij \in \Omega} \) and the result of the Newton iteration on coarsest level.
#+begin_src julia-vterm :results file graphics  :file v_cycle.svg :noweb strip-export :async t :exports results :output-dir images  :tangle plot.Jr :session Jr
<<setup-grid>>

p0 = heatmap(testgrd[1].phase, title="Initial State");
solver = testgrd[1]
set_xi_and_psi!(solver)
SMOOTH!(solver, 400, true);
p1 = heatmap(solver.phase, title="After Pre Smoothing");


d = zeros(size(solver.phase))
r = zeros(size(solver.phase))

for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]
    d[I], r[I] = [solver.xi[I], solver.psi[I]] .- L(solver, I.I..., solver.phase[I] , solver.potential[I])
end

p2 = heatmap(d, title="Phase Residuals");
level = 1

restrict_solver!(testgrd[level], testgrd[level+1])
solver =testgrd[level+1]
solution = deepcopy(solver)



d_large = restrict(d, G)
r_large = restrict(r, G)

println(" d $(norm(d_large))")
println(" r $(norm(r_large))")

u_large = zeros(size(d_large))
v_large = zeros(size(d_large))



for i = 1:300
    for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]


        diffrence = L(solution, I.I..., solution.phase[I], solution.potential[I]) .- [d_large[I], r_large[I]] .- L(solver, I.I... , solver.phase[I] , solver.potential[I])
        #diffrence = collect(L(solution, I.I...)) .- collect(L(solver, I.I...))
        #diffrence = [d_large[I] , r_large[I]]

        local ret = dL(solution , I.I...) \ diffrence
        #if I == CartesianIndex(2,2)  println("Diffrence: $(diffrence) , Ret: $(ret)") end

        u_large[I] = ret[1]
        v_large[I] = ret[2]
    end
    solution.phase .-= u_large
    solution.potential .-= v_large
end


p3 = heatmap(u_large, title=@sprintf "Change: %.1e" norm(u_large))
p = plot(p0, p1, p2,p3, layout=(2, 2));
savefig(p, "images/v_cycle.svg")
#+end_src

#+RESULTS:
[[file:images/v_cycle.svg]]

and a few iterations of the V-cycle exhibit the following behavior:

#+begin_src julia-vterm :results file graphics  :file iteration.gif :noweb strip-export :async t :exports both :output-dir images  :tangle plot.jl :session jl :eval never-export
<<setup-grid>>
set_xi_and_psi!(solver)

pbar = ProgressBar(total = 1000)

anim = @animate for i in 1:100
    for j in 1:10
        v_cycle!(testgrd, 1)
        update(pbar)
        end
    set_xi_and_psi!(testgrd[1])
    heatmap(testgrd[1].phase , clim =(-1,1) , framestyle=:none )
end
gif(anim , "images/iteration.gif" , fps = 10)
#+end_src

#+RESULTS:
[[file:images/iteration.gif]]

** SMOOTH Operator
[cite:@SHIN20117441]derive Gaus-Seidel Smoothing by:
\begin{align*}
L
\begin{pmatrix}
\phi^{n+1}_{ij} \\
\mu^{n+\frac{1}{2}}_{ij}
\end{pmatrix}
&=
\begin{pmatrix}
\zeta^n_{ij} \\
\psi^n_{ij}
\end{pmatrix}
\end{align*}
solved for \( \phi , \mu \).
 SMOOTH consists of point-wise Gauß Seidel Relaxation, by solving /L/ for \( \overline{\phi} ,\overline{\mu} \) with the initial guess for \( \zeta^n , \psi^n \).
\begin{align}
SMOOTH
\end{align}
and we implement it as
#+name:SMOOTH
#+begin_src julia :tangle multisolver.jl :eval never
function SMOOTH!(
    solver::multi_solver,
    iterations,
    adaptive
)
    for k = 1:iterations
        old_phase = copy(solver.phase)
        for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)

            coefmatrix = dL(solver, i,j )

            b =
                [
                    (
                        solver.xi[i, j]
                        +
                        discrete_G_weigted_neigbour_sum(
                            i, j, solver.potential, G, solver.len, solver.width
                        )
                        /
                        solver.h^2
                    ),
                    (
                        solver.psi[i, j]
                        -
                        (solver.epsilon^2 / solver.h^2)
                        ,*
                        discrete_G_weigted_neigbour_sum(
                            i, j, solver.phase, G, solver.len, solver.width
                        )
                    )
                ]

            res = coefmatrix \ b
            solver.phase[i, j] = res[1]
            solver.potential[i, j] = res[2]

        end

        if adaptive && LinearAlgebra.norm(old_phase - solver.phase) < 1e-8
            #println("SMOOTH terminated at $(k) succesfully")
            break
        end
    end
end
#+end_src

#+begin_src julia :results file graphics  :file smooth.svg :noweb strip-export :async t :exports results :output-dir images :session jl
<<setup-grid>>
set_xi_and_psi!(solver)
SMOOTH!(solver, 2, true);
p = heatmap(solver.phase, aspect_ratio=:equal ,xlim=(2 , solver.len));
savefig(p,"images/smooth.svg")
#+end_src

#+RESULTS:
[[file:images/smooth.svg]]

** Test Data:
For testing and later training we use a multitude o different phase fields. Notably an assortment of randomly placed circles, squares, and arbitrary generated values

#+name:inputs
| Size | blobs | blobsize | norm |
|------+-------+----------+------|
|   64 |    10 |       10 |    2 |
|   64 |    10 |       10 |  100 |
|  512 |    20 |       50 |    2 |

#+name: testdata
#+begin_src julia :eval never :tangle utils.jl
function testdata(gridsize , blobs , radius ,norm)
rngpoints = rand(1:gridsize, 2, blobs)
M = zeros(gridsize,gridsize) .- 1
for p in axes(rngpoints , 2)
    point = rngpoints[:, p]
    for I in CartesianIndices(M)
        if (LinearAlgebra.norm(point .- I.I  , norm) < radius)
            M[I] = 1
        end
    end
end
M
end
#+end_src

#+name: fig:testinput
#+begin_src julia-vterm :results file graphics  :file testdata.svg :noweb strip-export    :exports results
using Plots
using LaTeXStrings
using LinearAlgebra
<<testdata>>
p0 = heatmap(testdata(512, 20 , 50, 2));
p1 = heatmap(testdata(512 , 20 , 50 ,Inf));
p2 = heatmap(testdata(64 , 10 , 10,2));
p3 = heatmap(testdata(64 , 10 , 10 ,Inf));
p = plot(p0,p1,p2,p3, aspectratio=:auto, layout=(2,2));
savefig(p,"testdata.svg")
#+end_src

#+caption: Examples of different phasefields used as initial condition later on
#+RESULTS: fig:testinput
[[file:testdata.svg]]
* Numerical Evaluation
The analytical Chan-Hilliard equation exhibits mass conservation [[eq:massbal]] and a decrease in Energy \( E_{bulk} \) [[eq:energy]]. Therefore, we use discrete variants of those concepts as necessary conditions for a "good" solution. Furthermore, since \( E_{bulk} \) is closely correlated with potential Energy \( \mu \), we evaluate this difference as quality of convergence.
** Energy Evaluations
As discrete energy measure we use
\begin{align*}
E^{\text{bulk}} &= \sum_{i,j \in \Omega} \frac{\varepsilon^2}{2} |G\nabla \phi_{ij} |^2 + W\left(\phi_{ij}\right) \, dx \\
&= \sum_{i,j \in \Omega} \frac{\varepsilon^2}{2} G_{i+\frac{1}{2}j}D_x\phi_{i+\frac{1}{2}j} ^2 + G_{ij+\frac{1}{2}}D_y\phi_{ij+\frac{1}{2}}^2  + W\left(\phi_{ij}\right) \, dx \\
\end{align*}
#+begin_src julia :tangle utils.jl :eval never
function bulk_energy(solver::T) where T <: Union{multi_solver , relaxed_multi_solver}
    energy = 0
    dx = CartesianIndex(1,0)
    dy = CartesianIndex(0,1)
    W(x) = 1/4 * (1-x^2)^2
    for I in CartesianIndices(solver.phase)[2:end-1,2:end-1]
        i,j = I.I
        energy += solver.epsilon^2 / 2 * G(i+ 0.5,j ,solver.len, solver.width) * (solver.phase[I+dx] - solver.phase[I])^2 + G(i,j+0.5,solver.len ,solver.width) * (solver.phase[I+dy] - solver.phase[I])^2 + W(solver.phase[I])
        end
   return energy
end
#+end_src
** Massbalance
we calculate mass balance as:
\begin{align*}
bal &= \frac{\sum_{i,j \in \Omega} \phi_{ij}}{|\{(i,j) \in \Omega\}|}
\end{align*}
such that \( b = 1 \) means there is only phase one \( \phi \equiv 1 \) and \( b = -1 \) only phase -1 \( \phi \equiv -1 \)
** Tests
* Relaxed Problem
In effort to decrease the order of complexity, we propose the following relaxation to the classical Cahn Hillard Equation:
#+name: eq:relaxed-cahn-hilliard
\begin{align}
\partial_t \phi^\alpha  &= \Delta \mu \\
\mu &= \varepsilon ^2 \alpha(c^\alpha - \phi^\alpha) + W'(\phi)
\end{align}
this in turn requires solving an additional PDE each time-step to calculate \(c\).
 \( c \) is the solution of the following elliptical PDE:
\begin{align*}
- \Delta c^\alpha  + \alpha c^a &= \alpha \phi ^\alpha
\end{align*}
As ansatz for the numerical solver we propose
#+name: eq:discrete-relaxed-cahn-hilliard
\begin{align}
\frac{\phi_{ij}^{n+1,\alpha} - \phi_{ij}^{n,\alpha}}{\Delta t}  &=  \nabla _d \cdot (G_{ij} \nabla_d \mu_{ij}^{n+\frac{1}{2},\alpha} )  \\
 \mu_{ij}^{n+\frac{1}{2},\alpha} &= 2\phi_{ij}^{n+1,\alpha} - \varepsilon^2 a(c_{ij}^{n+1,\alpha} - \phi_{ij}^{n+1,\alpha})  + W'(\phi_{ij}^{n,\alpha}) - 2\phi _{ij}^{n,\alpha}
\end{align}
this approach is inspired by [[eq:discrete-relaxed-cahn-hilliard]] adapted to the relaxed Cahn-Hiliard equation [[eq:relaxed-cahn-hilliard]].
** relaxed operators:
we then adapt the multi-grid solver proposed earlier to the relaxed Problem by replacing the differential operators by their discrete counterparts as defined in [[eq:discretization]],
and expand them
*** L Relaxed
for the reformulation of the iteration in terms of Operator \(L\) then follows:
\begin{align*}
L
\begin{pmatrix}
\phi ^{n+1,\alpha} \\
\mu^{n+\frac{1}{2},\alpha}
\end{pmatrix}
&=
\begin{pmatrix}
\frac{\phi^{n+1,m,\alpha}_{ij}}{\Delta t} - \nabla _d \cdot (G_{ji} \nabla _d \mu^{n + \frac{1}{2},m,\alpha}_{ji}) \\
\varepsilon ^2 \alpha (c^\alpha - \phi^{n+1,m,\alpha}_{ij}) - 2\phi ^{n+1,m,\alpha}_{ij} -\mu^{n + \frac{1}{2},m,\alpha}_{ji}
\end{pmatrix}
\end{align*}

#+begin_src julia :tangle multi_relaxed.jl :eval never
function L(solver::relaxed_multi_solver,i,j , phi , mu)
    xi = solver.phase[i, j] / solver.dt -
         (discrete_G_weigted_neigbour_sum(i, j, solver.potential, G, solver.len, solver.width)
          -
          neighbours_in_domain(i, j, G, solver.len, solver.width) * mu )/solver.h^2
    psi = solver.epsilon^2 * solver.alpha*(solver.c[i,j] - phi) - 2 * solver.phase[i,j] - solver.potential[i,j]
    return [xi, psi]
end
#+end_src
and its relaxed derivative
\begin{align*}
DL\begin{pmatrix}
\phi \\
\mu
\end{pmatrix} &= \begin{pmatrix}
\frac{1}{\Delta t} & \frac{1}{h^2}\Sigma_{G}  \\
- \varepsilon^2 \alpha  - 2 & 1
\end{pmatrix}
\end{align*}
#+begin_src julia :tangle multi_relaxed.jl :eval never
function dL(solver::relaxed_multi_solver , i , j)
    return [ (1/solver.dt) (1/solver.h^2*neighbours_in_domain(i,j,G,solver.len , solver.width));
             (-1*solver.epsilon^2 * solver.alpha  - 2) 1]
    end
#+end_src

*** SMOOTH
and correspondingly the SMOOTH operation expands to:
\begin{align*}
SMOOTH( \phi^{n+1,m,\alpha}_{ij}, \mu^{n + \frac{1}{2},m,\alpha}_{ji}, L_h , \zeta^{n,\alpha} , \psi^{n,\alpha} )
\end{align*}

#+name: eq:discrete_relaxed_smooth
\begin{align}
  -\frac{\Sigma_G}{h^2}\overline{\mu}^{n + \frac{1}{2},m,\alpha}_{ji} &= \frac{\phi ^{n+1,m,\alpha}_{ij}}{\Delta t} - \zeta^{n,\alpha}_{ij} - \frac{\Sigma_G\mu_{ij}}{h^2} \\
 \varepsilon ^2 \alpha \overline{\phi} ^{n+1,m,\alpha}_{ij} + 2 \phi ^{n+1,m,\alpha}_{ij} &= \varepsilon ^2 \alpha c^{n,\alpha}_{ij}  -\mu^{n + \frac{1}{2},m,\alpha}_{ji}  - \psi_{ij}^{n,\alpha}
\end{align}

**** DONE Proposal1 :noexport:
Since the resulting system no longer is linear, (albeit simpler in Dimension), we propose a newton method to solve second equation (in conjunction with the first one) hopefully solving this converges faster than the original multiple SMOOTH Iterations.
 The iteration solves for \( (\phi ^{n+1,m}_{ij})^\alpha = x \) as free variable. Therefore, it follows for \( F(x) \)
\begin{align*}
F(x)  &= \varepsilon ^2 x^\alpha + 2x - \varepsilon^2 c^\alpha  + y + \psi_{ij} \\
y &= \frac{x}{\Delta t} - \zeta^n_{ij} \\
&- \frac{1}{h^2}\left(G_{i+\frac{1}{2}j} \mu^{n + \frac{1}{2},m}_{i+1j} +  G_{i-1j} \mu^{n + \frac{1}{2},m}_{i-1j} + G_{ij+1}  \mu^{n + \frac{1}{2},m}_{ij+1} + G_{ij-1} \mu^{n + \frac{1}{2},m}_{ij-1}\right) \\
&\cdot  \left(G_{i+1j} + G_{i-1j} + G_{ij+1} + G_{ij-1}\right)^{-1} \\
\end{align*}
And the derivative for the iteration is
        \begin{align*}
\frac{d}{dx} F(x)&= \alpha \varepsilon^2 x^{\alpha-1} + 2 + \frac{d}{dx} y  \\
\frac{d}{dx} y  &= \frac{1}{\Delta t}
\end{align*}
**** Proposal2
solve for \( \overline{\mu_{ij}^{n+1,m,\alpha}} \) and \( \overline{\phi_{ij}^{n+1,m,\alpha}} \). This was not done in the original paper[cite:@SHIN20117441] as the there required System of linear equations was solved numerically. The relaxation simplifies it to one dimension, and enables explicit solutions:
\begin{align*}
\varepsilon^2 \alpha(\phi^\alpha) + 2\phi^\alpha &= \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G} (\frac{\phi^\alpha}{\Delta t} - \zeta^n_{ij} - \frac{1}{h^2} \Sigma_G \mu_{ij}) - \psi_{ij}
\end{align*}
\( \implies \)
\begin{align*}
\varepsilon^2\alpha (\phi^\alpha) + 2\phi^\alpha + \frac{h^2}{\Sigma_G}\frac{\phi^\alpha}{\Delta t} &= \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G} (- \zeta^n_{ij} - \frac{1}{h^2} \Sigma_G \mu_{ij}) - \psi_{ij}
\end{align*}
\( \implies \)
\begin{align*}
(\varepsilon^2 \alpha + 2 + \frac{h^2}{\Sigma_G \Delta t}) \phi^\alpha = \varepsilon^2 \alpha c^\alpha - \frac{h^2}{\Sigma_G}(- \zeta^n_{ij} - \frac{\Sigma_G \mu_{ij}}{h^2} ) -\psi_{ij}
\end{align*}
solved for \( \phi_{ij}^{n+1\alpha}\) the Smoothing Operator then follows:
#+name: SMOOTH_relaxed
#+begin_src julia :eval never :tangle multi_relaxed.jl :file f.jl
function SMOOTH!(
    solver::relaxed_multi_solver,
    iterations,
    adaptive
)
    for k = 1:iterations
        old_phase = copy(solver.phase)
        for I in CartesianIndices(solver.phase)[2:end-1, 2:end-1]
            i, j = I.I
            bordernumber = neighbours_in_domain(i, j, G, solver.len, solver.width)


            solver.phase[I] = (solver.epsilon^2 * solver.alpha * solver.c[I] - solver.h^2 / bordernumber * ( -solver.xi[I]  - discrete_G_weigted_neigbour_sum(i,j,solver.potential , G , solver.len , solver.width) / solver.h^2 ) - solver.psi[I]) / (solver.epsilon^2 * solver.alpha  + 2 + solver.h^2 / (bordernumber*solver.dt))

            solver.potential[I] = (solver.phase[I]/solver.dt - solver.xi[I] - discrete_G_weigted_neigbour_sum(i,j, solver.potential , G , solver.len , solver.width)/solver.h^2) * (-solver.h^2/bordernumber)
        end

        if adaptive && LinearAlgebra.norm(old_phase - solver.phase) < 1e-10
            #println("SMOOTH terminated at $(k) succesfully")
            break
        end
    end
end
#+end_src

#+begin_src julia-vterm :file smooth_relaxed.svg :output-dir images :results file graphics :noweb yes :session
using Plots
using LaTeXStrings
using LinearAlgebra
include(pwd() *"/utils.jl")
<<SMOOTH_relaxed>>
SIZE =64
M = testdata(SIZE, 5 , 8, 2);
phase = zeros(size(M) .+ 2);
phase[2:end-1,2:end-1] = M;
mu = copy(phase);
W_prime(x) = -x * (1-x^2)
<<elyps_solver>>
solver = relaxed_multi_solver(
    phase ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    zeros(size(phase)) ,
    8e-3 ,1e-3 , 1e-3 ,
    W_prime ,
    size(M , 1) , size(M , 2),
    1000001
)
set_xi_and_psi!(solver)
elyps_solver!(solver , 2000)
SMOOTH!(solver, 1000, true);
p2 = heatmap(solver.phase, aspect_ratio=:equal, title="with solving c" , xlim=(2,SIZE) , ylim=(2,SIZE));
savefig(p2,"images/smooth_relaxed.svg")
#+end_src

#+RESULTS:
[[file:images/smooth_relaxed.svg]]
*** Relaxed V-cycle
As The difference between both methods is abstracted away in the operators, the relaxed V-cycle Is Identical to its original counterpart. And therefore reused.
Testing:
#+begin_src julia-vterm :results file graphics  :file iteration_relaxed2.gif :noweb strip-export  :exports both :output-dir images :session jl :eval never-export
<<setup-relaxed-grid>>
set_xi_and_psi!(solver)

pbar = ProgressBar(total = 1000)

anim = @animate for i in 1:100
    elyps_solver!(solver , 1000)
    for j in 1:10
        v_cycle!(testgrd, 1)
        update(pbar)
        end
    set_xi_and_psi!(testgrd[1])
    heatmap(testgrd[1].phase , clim =(-1,1) , framestyle=:none )
end
gif(anim , "images/iteration_relaxed2.gif" , fps = 10)
#+end_src

#+RESULTS:
[[file:images/iteration_relaxed2.gif]]

** Elliptical PDE:
on order to solve the relaxed CH Equation the following PDE as to be solved in Each additional time step:
or in terms of the characteristic function:
\begin{align*}
- \nabla \cdot  (G \nabla c^\alpha) + \alpha c^\alpha  = \alpha \phi ^\alpha
\end{align*}
Similarly to the first solver this PDE is solved with a finite difference scheme using the same discretization as before:
*** Discretization
the Discretization of the PIE expands the differential operators in the same way and proposes an equivalent scheme for solving.
\begin{align*}
- \nabla_d \cdot  (G_{ij} \nabla_d c_{ij}^\alpha) + \alpha  c_{ij}^\alpha &= \alpha \phi_{ij}^\alpha
\end{align*}
\( \implies \)
\begin{align*}
- (\frac{1}{h}(G_{i+\frac{1}{2}j} \nabla c^\alpha_{i+\frac{1}{2}j} + G_{ij+\frac{1}{2}} \nabla c^\alpha_{ij+\frac{1}{2}}) &  \\
- (G_{i-\frac{1}{2}j} \nabla c^\alpha_{i-\frac{1}{2}j} + G_{ij-\frac{1}{2}} \nabla c^\alpha_{ij-\frac{1}{2}})) + \alpha  c_{ij}^\alpha   &= \alpha  \phi_{ij}^\alpha
\end{align*}
\( \implies \)
\begin{align*}
- \frac{1}{h^2} ( G_{i+\frac{1}{2}j}(c_{i+1j}^\alpha - c_{ij}^\alpha) & \\
+G_{ij+\frac{1}{2}}(c_{ij+1}^\alpha - c_{ij}^\alpha) & \\
+G_{i-\frac{1}{2}j}(c_{i-1j}^\alpha - c_{ij}^\alpha)& \\
+G_{ij-\frac{1}{2}}(c_{ij-1}^\alpha - c_{ij}^\alpha)) + \alpha  c_{ij}^\alpha &=\alpha  \phi_{ij}^\alpha
\end{align*}


As before we abbreviate \(  \Sigma_G c^\alpha_{ij} = G_{i+\frac{1}{2}j} c^\alpha_{i+1j} +  G_{i-\frac{1}{2}j} c^\alpha_{i-1j} + G_{ij+\frac{1}{2}}  c^\alpha_{ij+1} + G_{ij-\frac{1}{2}} c^\alpha_{ij-1}  \) and \(  \Sigma_G = G_{i+\frac{1}{2}j} + G_{i-\frac{1}{2}j} + G_{ij+\frac{1}{2}} + G_{ij-\frac{1}{2}}  \). Then the discrete elliptical PDE can be stated as:
#+name: eq:discrete_elyps
\begin{align}
-\frac{ \Sigma_G c^\alpha_{ij}}{h^2} + \frac{\Sigma_G}{h^2} c^\alpha_{ij} + \alpha c^\alpha_{ij} &= \alpha\phi^\alpha_{ij}
\end{align}

**** DONE Proposal1 Newton Solver
And then we propose a simple newton Iteration to solve  [[eq:discrete_elyps]]  for \( x = c^\alpha_{ij} \):
Let \( F, dF \) be:
\begin{align*}
F(x) &= - \frac{\Sigma_Gc^\alpha_{ij}}{h^2} + \frac{\Sigma_G}{h^2}  x + \alpha x  - \alpha \phi_{ij}^\alpha
\end{align*}
and \( dF(x) \)

\begin{align*}
dF(x) &= - \frac{\Sigma_G}{h^2}    + \alpha
\end{align*}
the implementation then is the following:

as input, we use :

**** Proposal2  solver
solving [[eq:discrete_elyps]] for \(c_{ij}^\alpha \) then results in.
\begin{align*}
\left( \frac{\Sigma_{G}}{h^2} + \alpha \right)c_{ij}^{\alpha} = \alpha\phi^{\alpha}_{ij} + \frac{\Sigma_G c_{ij}^{\alpha}}{h^2}
\end{align*}
and can be translated to code as follows
#+begin_src julia :eval never :tangle elypssolver.jl :exports none
using ProgressBars

"""
    elyps_solver(c,
    phase,
    len,
    width,
    alpha,
    h,
    n
)

TBW
"""
#+end_src
#+name: elyps_solver
#+begin_src julia :eval never :tangle elypssolver.jl
function elyps_solver!(solver::relaxed_multi_solver, n)
    for k in 1:n
        for i = 2:(solver.len+1)
            for j = 2:(solver.width+1)
                bordernumber = neighbours_in_domain(i, j,G, solver.len, solver.width)
                solver.c[i, j] =
                    (
                        solver.alpha * solver.phase[i, j] +
                        discrete_G_weigted_neigbour_sum(i, j, solver.c, G, solver.len, solver.width) / solver.h^2
                    ) / (bordernumber / solver.h^2 + solver.alpha)

            end
        end
    end
end
#+end_src
**** DONE Proposal 4 :noexport:
as the solver still exhibits unexpected behavior, i.e. it doesn't seem to converge wit higher iterations, we propose a relaxation by interpolating the new value of \(  c_{ij}^\alpha \) with the old one

* References
#+PRINT_BIBLIOGRAPHY:
#  LocalWords:  Discretization
